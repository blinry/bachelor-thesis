\documentclass[twoside]{scrreprt}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

\usepackage{url}
\usepackage{soul}
\sethlcolor{darkgray}
\newcommand{\invert}[1]{\textcolor{white}{\hl{#1}}}
\newcommand{\cursor}{\invert{ }}
\newcommand{\escape}[1]{\textasciicircum #1}

\usepackage[hidelinks]{hyperref}
%\usepackage{savetrees}

\usepackage[os=win]{menukeys}
\usepackage{syntax}
\usepackage{listings}
\renewmenumacro{\keys}[+]{shadowedroundedkeys}

\usepackage{courier}
\usepackage{microtype}
\DisableLigatures[<,>]{family=tt*}

\lstset{
    aboveskip=20pt,
    belowskip=20pt,
    basicstyle=\small\ttfamily,
    %numbers=left,
    numberstyle=\tiny,
    frame=tb,
    columns=fullflexible,
    showstringspaces=false,
    literate=%
    {~}{\url{~}}1
}

\titlehead{\sffamily\bfseries\centerline{Braunschweig University of Technology}\centerline{Institute for Programming and Reactive Systems}}

\subject{Bachelor Thesis}
\title{The Nut Shell - A Framework for Creating Interactive Command Line Tutorials}
\author{Sebastian Morr \texttt{<sebastian@morr.cc>}}
\date{2013-11-03}
\publishers{\textbf{Thesis Advisors:} \\ Prof. Dr. Ursula Goltz \\ (Zweitprüfer) \\ Dr. Werner Struckmann}

\begin{document}

\maketitle

\begin{abstract}
    (Purpose)

    (Design + evaluation methods)

    (Major results)

    (Summary of conclusions)

    \vspace{8em}

    (German translation)
\end{abstract}

\setcounter{tocdepth}{1}
\tableofcontents

\chapter{Introduction}

Command line interfaces are powerful, efficient methods to interact with computers, but they often have a steep learning curve.

The common way of teaching command line interfaces is a static text. This representation has several disadvantages: The users have to shift their attention forth and back between the tutorial text and the system they are learning, which could make the learning process ineffective. The text might set goals, but those aren't affirmed when they are reached. Last, when the user makes a syntactical or semantical mistake, the text does not respond to help the user fix it.

This thesis describes a system that strives to fix those problems. The core idea is to interlace the tutorial text and the command line output so that the text can respond to the state of the command line system. This approach is inspired by text adventures.

(Aufgabenstellung highlighten!)

The framework can be used to learn and teach arbitrary command line interfaces, for example system shells (bash, zsh, …), read eval print loops of various programming languages (Ruby, Python, Haskell, …), tools like Git or other VCS's, Makefiles, compiler toolchains or the UNIX directory structure.

The main research question of this thesis is whether this approach is in some way "better" than the traditional text tutorials.

In the technical community, there have been several approaches in creating interactive tutorials for command line interfaces, most notably (Try Ruby/Git/Haskell).

(What's missing in them)

\section{Overview}

The \emph{Nut Shell} is designed to be a wrapper around a common command line process.

(Diagram of loop?)

The goal is to be able to adapt to any command line interface -- how this abstraction is achieved is described in (ch x).

The Nut Shell will be designed in such a way that the command line's output will be let through unchanged, and will only be annotated.

This thesis covers design, implementation, application and evaluation of the \emph{Nut Shell}.

Design-wise, the framework consists of three layers:

- A lowlevel layer that abstracts the target command line interface to a common API.

- The highest layer parses and interprets the nutsh files and recudes them to API calls of the lower layer.

(Diagram: Layers)

Implementation details follow in (ch x).

To find out whether this teaching approach has benefits, the framework was applied and evaluated in an eight-day study with about xx participants, this is described in (ch x).

\chapter{Preliminaries}

\section{Command Line Interface}

A \emph{Command Line Interface} (\textsc{CLI}) allows a user to communicate with a computer program by entering lines of text, the so-called \emph{command lines}. Although some have graphical capabilities (src), this thesis focuses on purely character-based interfaces.

Commonly, interaction with a \textsc{CLI} can be seperated into three phases:

\begin{enumerate}
    \item The program writes a \emph{prompt}, which a special character sequence that signals that the program now accepts a command.
    \item The user composes a command line, often using several editing capabilities offered by the CLI. To tell the program to execute the command, the \emph{return} character is used. (rlly?)
    \item The program executes the command and prints a response. Sometimes, the execution is interactive (ref reaktive systeme) and does not return until the user tells the program to. After the command has finished, the first phase is entered again.
\end{enumerate}

Here is an example of one iteration of these phases.\footnote{The \textsc{CLI} in this case is an \emph{Interactive Ruby Shell}.} The \texttt{>\->} is the prompt, the \texttt{2**10} is the command line entered by the user, and the \texttt{1024} is the command's output:

\begin{lstlisting}
>> 2**10
1024
\end{lstlisting}

\section{Terminal}

In the past, a \emph{computer terminal} was a device that was used to communicate with mainframe computers. They read text from the user via a keyboard and displayed the computer's output, first on paper, later on a screen. (src: wiki)

Here, when we use the term \emph{terminal}, we mean a modern \emph{terminal emulator}, a program that resembles a terminal within an otherwise graphical environment. Inside of these terminal emulators, \textsc{CLI}s can be used.

Terminals communicate through sequential streams of characters: They receive characters from a program to be displayed, and they receive characters from the user's keyboard, which they send back to the program.

\subsection{Escape codes}

A classical computer terminal was the \textsc{VT100}, introduced 1978 by \textsc{Digital Equipment Corporation}. Its behaviour is nowadays emulated by modern terminal emulators. The device had a mechanism for doing graphical output: By sending special character sequences, the terminal performed special actions like moving the cursor, deleting characters on the screen or turning graphical modes (underlining, different colors) on and off. The \textsc{VT100} supported the escape sequences defined in ANSI X3.64 (ref), also called the \emph{ANSI escape sequences}.

(...)

\subsection{Readline}

To allow comfortable text input, and to enable functions like command line editing or a command history, many (quot) programs use a library called \emph{readline}. This library has some default keybindings, of which we utilize the following:

(come from emacs)

\begin{figure}
    \begin{tabular}{r|r}
        Key combination & effect \\
        \hline
        Ctrl + U & delete line \\
    \end{tabular}
\end{figure}

\section{Targets}

(what does a target need?)

(customizable prompt)
(readline)

\chapter{Command Line Parser}

The purpose of the Command Line Parser is to recognize the different parts of the interaction with a running command line process. To do this, it wraps around the \textsc{CLI} process, watches and modifies its input and output. This way, it provides a common interface to arbitrary targets.

The interesting parts in this context are the following, which correspond to the three phases described in (ref):

\begin{enumerate}
    \item Which prompt is displayed to the user?
    \item Which command is entered?
    \item What is the output of this command?
\end{enumerate}

In this thesis, the target command line process is treated as a black box having both input and output streams of Unicode characters. To recognize which commands the user entered and what the corresponding output is, the framework needs to parse the output accordingly.

For this purpose, we use two special \emph{markers}, which enable the parser to recognise the different parts. These are special character sequences that don't appear in normal output. (clarify)

\section{Recognizing the command}

While the user edits the command line, they can use many of readline's key bindings or other shell builtin key combinations. These make it hard to recognize which command was entered, as parts of the entered characters could have been deleted or otherwise changed. To solve this, we use a mechanism to repeat the entered line before it is sent.

All targets support (by definition, through Readline) the keyboard shortcuts \keys{\ctrl+U} and \keys{\ctrl+Y}, which delete the momentarily entered command and put it in a internal buffer / re-insert it. The parser waits for the user to press Enter and then sends the sequence

\begin{quote}
    \keys{\ctrl+U} marker \keys{\backspace} \keys{\ctrl+Y} marker \keys{\backspace} \keys{\return}
\end{quote}

to the underlying process. The result is that the entered command is appearing in the output cleanly framed by the two markers, while the output looks the same to the user.

Here is a demonstration of this technique. The first column lists the user's keystrokes, the second one contains the characters sent to the process, the third one contains the output of the process, and the last one shows the current content of the terminal.

\begin{tabular}{l|l|l|l}
    Keystrokes & Input & Output & Screen content \\
    \hline
    & & \texttt{>>␣} & \texttt{>>␣\cursor} \\
    \keys{1} \keys{-} \keys{1} & \texttt{1-1} & \texttt{1-1} & \texttt{>>␣1-1\cursor} \\
    \keys{\arrowkeyleft} & \texttt{\escape{[}[D} & \texttt{\escape{H}} & \texttt{>>␣1-\invert{1}} \\
    \keys{backspace} & \texttt{\escape{H}} & \texttt{\escape{H}} & \texttt{>>␣1\invert{-}1} \\
    & & \texttt{\escape{[}[1P} & \texttt{>>␣1\invert{1}} \\
    \keys{{+}} & \texttt{+} & \texttt{+} & \texttt{>>␣1+\cursor} \\
    & & \texttt{1} & \texttt{>>␣1+1\cursor} \\
    & & \texttt{\escape{H}} & \texttt{>>␣1+\invert{1}} \\
    \keys{\return} & \texttt{\escape{E}} & \texttt{\escape{[}[C} & \texttt{>>␣1+1\invert{ }} \\
    & \texttt{␣} & \texttt{␣} & \texttt{>>␣1+1␣\invert{ }} \\
    & \texttt{\escape{U}} & \texttt{\escape{H}\escape{H}\escape{H}\escape{H}} & \texttt{>>␣\invert{1}+1␣} \\
    & & \texttt{\escape{[}[K} & \texttt{>>␣\invert{ }} \\
    & \texttt{\{marker\}} & \texttt{\{marker\}} & \texttt{>>␣\{marker\}\invert{ }} \\
    & \texttt{\escape{H}} & \texttt{\escape{H}\escape{[}[K} & \texttt{>>␣\invert{ }} \\
    & \texttt{\escape{Y}} & \texttt{1+1␣} & \texttt{>>␣1+1␣\invert{ }} \\
    & \texttt{\{marker\}\escape{H}} & \texttt{\{marker\}\escape{H}\escape{[}[K} & \texttt{>>␣1+1␣\invert{ }} \\
    & \texttt{\escape{H}} & \texttt{\escape{H}\escape{[}[K} & \texttt{>>␣1+1\invert{ }} \\
\end{tabular}

The full output of this sequence is (...), and by taking the characters between the markers and discarding the first two (for deletion of the marker itself) and the last (the space) we get the exact command line the user wishes to send.

\section{Interactivity}

The \textsc{CLI} can start other programs which run in the foreground, that is, wait for the user to enter text. These programs are called \emph{interactive}. Examples are text editors or pagers, that show a long text and allow the user to scroll up and down. With this kind of prompt you cannot wait for the command to finish, but you have to show the output to the user beforehand, so they can interact with it.

The parser solves this by using a timer: If a command runs longer than (x) milliseconds, that is, when the parser waits longer than that for a marker, it switches to \emph{interactive mode}, which shows the output directly.

\section{Recognizing the Prompt}

The prompt is configured to start and end with a marker. This leads to problems when the user tries to reconfigure the prompt.

\section{Multi Line Commands}

The are \textsc{CLI}s which recognize that a command is incomplete. In this case, they do not send the command, but give the user the possibility to complete it. Usually, the CLI displays a second, special prompt in this case. The parser inserts markers there, too, so that it can be differeniated from a normal prompt.

After the above enter handling, the parser looks at the next character - if it is a secondary-prompt-marker, it falls back to command-editing mode. In the end all such part-command-lines are appended to get the full command.

\section{Architecture}

Putting it all together:

(Component diagram)

(ref: ebnf)

%blabla \synt{command} blabla \lit{bla}

The output of the process consists of three phases: The prompt with the markers, the composing of the command (which can include escape sequences for editing, or can consist of several lines), and the command's output:

\begin{grammar}
<process_output> ::= \{ <prompt_with_markers> <command_composing> <command_output> \}
\end{grammar}

The prompt begins and ends with markers, which may not appear inbetween:

\begin{grammar}
<prompt_with_markers> ::= <marker> <prompt> <marker>

<prompt> ::= \{ <non_marker_character> \}

<non_marker_character> ::= everything but marker/marker2
\end{grammar}

The composing phase begins with a composing sequence, where the user enters and edits a line, optionally followed by more lines, each preceeded by a secondary prompt:

\begin{grammar}
<command_composing> ::= <composing_and_echo> [\{ <prompt2_with_markers> <composing_and_echo> \}]

<prompt2_with_markers> ::= <marker2> <prompt> <marker2>
\end{grammar}

The composing sequence has two phases: In the first one, the actual line composing takes place. In the second one, the current line is deleted and reprinted. The latter phase happens as described in (ref) above: The line is deleted, a marker is sent and deleted, the command is printed, a second marker is print and deleted, and a newline is sent:

\begin{grammar}
<composing_and_echo> ::= <line_composing> <command_echo>

<line_composing> ::= \{ <non_marker_character> \}

<command_echo> ::= <deletition> <marker> <deletion> <command> <marker> <deletion> <newline>

<deletition> ::= \{ <deletition_character> \}

<deletition_character> ::= \lit{\textasciicircum W} | \lit{\textasciicircum K} | ...

<newline> ::= \lit{\textbackslash r}
\end{grammar}

Finally, the command output simply consists of non marker characters:

\begin{grammar}
<command_output> ::= \{ <non_marker_character> \}
\end{grammar}

%<marker> ::= '☃'
%<marker2> ::= '★'

(example)

\chapter{The nutsh Language}

The \emph{nutsh} language is designed to describe a self-contained teaching unit, a "lesson".

\section{Design Goals}

Lesson files should be as easy to read and to write as possible.

The author decided to use a syntax close to the ones potential users will already know, that is, regular expressions and for the rest a syntax similar to Go. C users will also feel at home.

The language contain syntactic structures that support often-used semantical statements.

Redundance should be minimized -- the language should contain possibilities to reuse code snippets to avoid repeating them.

\section{Properties}

The language is string-based, the only data type is a string of Unicode characters. This was done to keep the language minimal.

nutsh does not have variables, which makes the language functional.

\section{Lexical Elements}

(Token types)

(Diagram: State machine)

\section{Syntax}

\subsection{Basics}

The nutsh language is based heavily on Strings (\texttt{"foo"}). String expressions can be concatenated (\texttt{"foo"+"foo"} has the same value as \texttt{"foofoo"}) and be checked for equality (\texttt{"foo" == "foo"}). Additionally, you can check whether a string matches a regular expression (\texttt{"foo" =~ "f.."}) (flavor). Every string can be interpreted as a truth value, which is \emph{false} for an empty string and \emph{true} otherwise. The common logic operators (\texttt{!} for \emph{not}, \texttt{\&\&} for \emph{and}, and \texttt{||} for \emph{or} are defined accordingly. They return the arbitrary String \texttt{"true"} for a truth value.

There are the control flow structures \emph{if-else} as well as \emph{prompt}, and you can define and call function. Variables are not neccessary, as you can define them in the target language.

There are typical C-comments (\texttt{//} for line comments, \texttt{/* ... */} for block comments).

\subsection{Basic Commands}

A central command is the output of explanation text. This text will be displayed indented and highlighted in a different color.

\begin{lstlisting}
say("This is explaining text.")
\end{lstlisting}

Because this command is used so often, it can be abbreviated to:

\begin{lstlisting}
"This is the short form."
\end{lstlisting}

To execute a command in the target process, you use \texttt{run()}. Value of this statement is the command's output.

\begin{lstlisting}
run("1+1")
\end{lstlisting}

\subsection{Control Flow}

Central is the prompt loop:

\begin{lstlisting}
prompt {
    // commands
}
\end{lstlisting}

It has the semantic of an endless loop, where at the beginning of each pass a command is read from the user. It can be left with a \texttt{break} statement.

There are two builtin functions called \texttt{command} and \texttt{output}, that correspond to the last user command and its output.

The language has \texttt{if-alse} expressions, whose syntax is influenced by Go (no brackets around the expression):

\begin{lstlisting}
if command =~ "42" {
    "Your command contained the number 42."
} else {
    "Your command did not contain the number 42."
}
\end{lstlisting}

\subsection{Functions}

To reuse code snippets, you can put them into functions:

\begin{lstlisting}
def exit_status {
    return(run("echo $?"))
}

def say_twice(text) {
    say(text)
    say(text)
}

prompt {
    say_twice("The exit status was '"+exit_status+"'")
}
\end{lstlisting}

Functions without arguments can be called without brackets as well.

\subsection{Umgebende Zustände}

If you want to check the same condition for a group of prompt statements, you can use this syntax:

\begin{lstlisting}
def help {
    if command =~ "help" {
        "Don't panic!"
    }
}

help {
    prompt {
        if command =~ "panic" {
            break
        }
    }

    "Zweite Chance..."
    prompt {
        if command =~ "panic" {
            break
        }
    }
}
\end{lstlisting}

At the beginning of each prompt loop, the function \texttt{help} is executed once. This works with multiple functions as well, which can be specified as a comma seperated list:

\begin{lstlisting}
def stay_in(dir) {
    if ! run("pwd") =~ "^"+dir {
        say("Please come back to `"+dir+"`!")
        prompt {
            if run("pwd") =~ "^"+dir {
                break
            }
        }
        "Okay, let's continue."
    }
}

def help {
    if command =~ "help" {
        "Don't panic!"
    }
}

run("cd /tmp")

stay_in("/tmp"), help {
    "How late is it?"
    prompt {
        if command == "date" {
            break
        }
    }

    "And who are you?"
    prompt {
        if command == "whoami" {
            break
        }
    }
}
\end{lstlisting}

\subsection{Grammar}

(EBNF of language constructs)

\section{Parsing}

(How YACC works)

\section{Semantics}

(Specification of language constructs)

\section{Interpreter}

(State)

(Function stack)

\section{Automated Testing}

To check that the lessons work, the tutorial's author needs a method to test the correctness of the lessons automatically, so they doesn't have to enter all the commands by hand.

(c0/c1)...

(Testing algorithm)

\section{Examples}

\chapter{Implementation}

\section{Used Technologies}

The framework was implemented in Go (src), a compiled, statically typed language, which is seen by many as a modern successor to C.

(kr/pty for terminal emulation)

\section{High-level Design}

(Diagram: Package diagram)

\section{Command Line Tool}

\subsection{Usage}

\subsection{Builtin Functions}

\chapter{Application and Evaluation}

To find out whether the teaching method provided by the Nut Shell has any advantages compared to classical tutorials, we created an example tutorial and conducted a two-week course with subsequent survey.

\section{Setting}

The \textsc{Braunschweig University of Technology} organizes preparatory Computer Science courses for freshman students every semester since (year). This course has two parts: One is about basic theoretical concepts of algorithms, the other one is about programming and related tools. (copy from descr.) The evaluation was conducted in the context of the second part.

Before, the topics were tought by handing out exercises on paper, which could be worked on in computer pools. For suport, student assistants were provided, with one assistant per approximately 25 students.



\section{Content}

In summary, the course was about learning how to use the system shell \emph{bash} and various command line tools. This included the following topics: The UNIX file system, text editors, process management, text tools like \texttt{grep}, \texttt{sort}, or \texttt{patch}, various shell mechanism like output redirection, shell scripts, Makefiles, ssh, \LaTeX, Java, Git.

The Nut Shell tutorial that we created kept these topics and their order, but presented them in a different fashion: 

For an example of such a tutorial, refer to (app x).

\subsection{Best practises in lesson writing}

provide "echo help"
let the user play
let the user choose paths
introduce metaphors
...

\section{Survey}

After the sixth day, an online survey was conducted whithin both groups.

\subsection{General questions}

The following questions were asked (in German):

\begin{itemize}
    \item What is your course of studies?
    \item On a range from 1 (not at all) to 10 (entirely), how much do you agree to the following statements?
        \begin{itemize}
            \item I had previous knowledge about the command line.
            \item The tutorial was fun.
            \item I learned a lot in the tutorial.
            \item The exercises were too hard.
            \item I had enough time to complete the exercises.
            \item I think the material is relevant for my further education.
            \item I would recommend the tutorial to others.
        \end{itemize}
    \item How many times per day did you have to ask for help?
\end{itemize}

\subsection{Quiz}

The second part of the survey was a quiz with 11 questions about different topics of the tutorial, in an attempt to measure how much the participants learned. The following questions were provided by a person who was uninvolved with and unaware of the content of the Nut Shell lessons (thanks!) to avoid a bias which could have led to asking questions we knew the Nut Shell explained well.

\begin{itemize}
    \item How do you copy the file \texttt{abc.txt} to the directory \texttt{xyz}?
    \item How can you obtain more information about the command \texttt{mv}?
    \item Name at least two ways to look at the content of the file \texttt{abc.txt}.
    \item What do you use the command \texttt{ln} for?
    \item Output all lines of the file \texttt{abc.txt} that contain the Text "Hallo".
    \item What is the variable \texttt{PS1} used for?
    \item What do you use \texttt{>} and \texttt{>>} for and how do they differ?
    \item How dou you archive and compress all files with the ending "123" in the current directory?
    \item What is the file \texttt{~/.bashrc} used for?
    \item You don't want to type \texttt{ls -alR} all the time, but create a short hand form. Which possibilities do you have and what is the corresponding command?
    \item What are pipes used for and how do you use them. Write an example command.
\end{itemize}

\section{Results}

(Pretty graphs)

(Statistical evaluation)

\chapter{Conclusions}

(Discussion of survey results)

\chapter{Limitations and Future Directions}

Right now, typing errors can be catched by defining some command-rules by hand. The expect-Statements could be used to automate this detection of typing errors by applying (algorithm).

    (Simplified prompt syntax)

    (Lesson dependency tree)

I plan to extend the Nut Shell further and release it under an Open Source license to allow others to benefit from it.

\chapter*{Acknowledgements}

I would like to thank the following people for their support in the creation of this thesis:

Hauke Baller,
Arne Brüsch,
Hendrik Freytag,
Heike Laschin,
Moritz Mühlhausen,
Markus Reschke,
Werner Struckmann,
Wolfgang Morr,
Leslie Wöhler

\chapter{References}

Unix Power Tools
wikipedia: backspace
ansi
vt100
The author of this paper designed a Nut Shell tutorial to teach the bash shell.

ebnf
tree evaluation
statistical method

\appendix

\chapter{Example Lesson}

(nutsh source code)

(Execution output)

\chapter{Implementation}

    limesurvey

\chapter{Table of Terminal Escape Codes}

(...)

\chapter*{Affidavit}

("Erklärung an Eides statt")
\vspace{8em}
(german)

\end{document}
