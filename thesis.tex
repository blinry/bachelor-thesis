\documentclass[paper=a4,twoside,abstract=on,cleardoublepage=empty,numbers=noenddot,toc=bib,12pt]{scrreprt}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage[ngerman,english]{babel}

\usepackage{blindtext}
\usepackage{multicol}
\usepackage{pgfplots, pgfplotstable}
    \pgfplotsset{compat=1.8}
    \usepgfplotslibrary{statistics}
    \pgfplotsset{
        boxplotcompare style/.style={
            boxplot/draw direction=x,
            % width of boxes:
            boxplot/box extend=0.3,
            % visualize the median as a circle:
            boxplot/draw/median/.code={%
                \draw[fill=white]
                (boxplot cs:\pgfplotsboxplotvalue{median}) circle (3pt)
                ;
            },
        },
        rshift/.style={
            yshift=+\pgfkeysvalueof{/pgfplots/rshift scale},
            legend image post style={yshift=-\pgfkeysvalueof{/pgfplots/rshift scale}},
            solid,
            fill=gray,
            thick,
        },
        lshift/.style={
            yshift=-\pgfkeysvalueof{/pgfplots/lshift scale},
            legend image post style={yshift=\pgfkeysvalueof{/pgfplots/lshift scale}},
            solid,
            fill=white,
            thick,
        },
        rshift scale/.initial=1.2em,
        lshift scale/.initial=1.2em,
    }

\usetikzlibrary{patterns}
    \makeatletter
    \newcommand\resetstackedplots{
        \makeatletter
        \pgfplots@stacked@isfirstplottrue
        \makeatother
        \addplot [forget plot,draw=none] coordinates{(1,0) (2,0) (3,0) (4,0) (5,0) (6,0) (7,0) (8,0) (9,0) (10,0) (11,0)};
    }
    \makeatother

\usepackage{soul}
    \sethlcolor{darkgray}
    \newcommand{\invert}[1]{\textcolor{white}{\hl{#1}}}
    \newcommand{\cursor}{\invert{ }}
    \newcommand{\escape}[1]{\textasciicircum #1}
\usepackage[hidelinks]{hyperref}
\usepackage{cleveref}
\usepackage[os=win]{menukeys}
    \renewmenumacro{\keys}[+]{shadowedroundedkeys}
\usepackage{syntax}
%\usepackage{courier}
\usepackage{microtype}
    \DisableLigatures[<,>]{family=tt*}
\usepackage{geometry}
\usepackage{listings}
    \lstdefinelanguage{nutsh}{
        morekeywords={if,else,prompt,def,break,return},
        sensitive=false,
    morecomment=[l]{//},
    morecomment=[s]{/*}{*/},
    morestring=[b]"
    }
    \lstset{
        aboveskip=10pt,
        belowskip=10pt,
        basicstyle=\ttfamily,
        columns=fullflexible,
        showstringspaces=false,
        literate={`}{\`}1,
    }
    \lstnewenvironment{ebnf}{\lstset{language=,frame=tbrl}}{}
    \lstnewenvironment{nutsh}{\lstset{language=nutsh,xleftmargin=\parindent}}{}


\titlehead{\sffamily\bfseries\makebox[\textwidth]{TECHNISCHE UNIVERSITÄT CAROLO-WILHELMINA ZU BRAUNSCHWEIG}}

\subject{\normalfont\sffamily Bachelor Thesis}
\title{The \emph{Nut Shell}---A Framework\\for Creating Interactive\\Command Line Tutorials}
\author{\sffamily Sebastian Morr \texttt{<sebastian@morr.cc>}}
\date{\sffamily 2013--11--02}
%\date{2013-11-03}
\publishers{
\begin{center}
    \includegraphics[width=23mm]{tu-bs-signet.pdf}
\end{center}
\vspace{15mm}\sffamily\normalsize%
Institute for Programming and Reactive Systems\\
Prof. Dr. Ursula Goltz\\[\baselineskip]
Advisor: Dr. Werner Struckmann}
\uppertitleback{
    \subsection*{Affidavit}
    This thesis is my own unaided work. All sources used are acknowledged as references.

    Ich habe diese Abschlussarbeit selbstständig verfasst. Alle Quellen wurden kenntlich gemacht.
    \\\\
    Braunschweig, 2013--11--03
    \vskip 10mm
    \hfill\hrulefill
}

%\vspace{2cm}

%Braunschweig, 2013-11-03 \dotfill}
\lowertitleback{
\subsection*{Acknowledgements}

I would like to thank the following people for their support in the creation of this thesis:

Hauke Baller,
Arne Brüsch,
Hendrik Freytag,
Heike Laschin,
Moritz Mühlhausen,
Markus Reschke,
Werner Struckmann,
Wolfgang Morr,
and Leslie Wöhler.

\subsection*{Colophon}

This document was created using \LaTeXe\ by Leslie Lamport and contributors, and \KOMAScript\ by Frank Neukam, Markus Kohm, and Axel Kielhorn. The figures were created using PGFPlots by Christian Feuersänger, key combinations using \texttt{menukeys} by Tobias Weh. The text is set in the Latin Modern font family by Bogusław Jackowski, Janusz M. Nowacki and Marcin Woliński.}

\begin{document}

\newgeometry{left=2cm,right=2cm}
\maketitle
\restoregeometry

%\clearpage
%\pagenumbering{roman}

\begin{abstract}

    \blindtext

    (Purpose)

    (Design + evaluation methods)

    (Main results)

    (Summary of conclusions)
\end{abstract}

\selectlanguage{ngerman}%
\begin{abstract}
    \blindtext

    (German translation)
\end{abstract}
\selectlanguage{english}%

\setcounter{tocdepth}{2}
\tableofcontents

%\cleardoublepage
%\pagenumbering{arabic}

\chapter{Introduction}

Command line interfaces are powerful, efficient methods to interact with computers, but they often have a steep learning curve.

The common way of teaching command line interfaces is a static text. This representation has several disadvantages: The users have to shift their attention forth and back between the tutorial text and the system they are learning, which could make the learning process ineffective. The text may set goals, but those aren't affirmed when they are reached. Finally, when the user makes a syntactical or semantical mistake, the text does not respond to help the user fix it.

This thesis describes a system that strives to fix those problems. The core idea is to interlace the tutorial text and the command line output so that the text can respond to the state of the command line system. This approach is inspired by text adventures.

(Aufgabenstellung highlighten!)

The framework can be used to learn and teach arbitrary command line interfaces, for example system shells (bash, zsh, …), read eval print loops of various programming languages (Ruby, Python, Haskell, …), tools like Git or other VCS's, Makefiles, compiler toolchains or the UNIX directory structure.

The main research question of this thesis is whether this approach is in some way "better" than the traditional text tutorials.

In the technical community, there have been several approaches in creating interactive tutorials for command line interfaces, most notably (Try Ruby/Git/Haskell).

(What's missing in them)

\section{Overview}

bottom-up...

At the core, the \emph{Nut Shell} is a wrapper around a common command line process.

(Diagram of loop?)

The goal is to be able to adapt to any command line interface---(ch x) describes how this abstraction is achieved.

The \emph{Nut Shell} lets through the command line's output unchanged, and will only add annotations.

This thesis covers design, implementation, application and evaluation of the \emph{Nut Shell}.

Design-wise, the framework consists of three layers:

- A lowlevel layer that abstracts the target command line interface to a common API.

- The highest layer parses and interprets the nutsh files and recudes them to API calls of the lower layer.

(Diagram: Layers)

Implementation details follow in (ch x).

To find out whether this teaching approach has benefits, the framework was applied and evaluated in an eight-day study with about xx participants, this is described in (ch x).

\section{Notation}
\label{sec:ebnf}

For specifying grammars, we use EBNF (ref). Here is the EBNF flavour as used in (ref), described in itself.
As a convention, we use use capitalized names for nonterminal symbols and lowercase names for terminal symbols.

\begin{ebnf}
Grammar     = { Production }
Production  = production_name "=" [ Expression ] "." .
Expression  = Alternative { "|" Alternative } .
Alternative = Term { Term } .
Term        = production_name | token | Group | Option | Repetition .
Group       = "(" Expression ")" .
Option      = "[" Expression "]" .
Repetition  = "{" Expression "}" .
\end{ebnf}

\chapter{Preliminaries}

\section{Command Line Interface}
\label{sec:cli}

A \emph{Command Line Interface} (\textsc{CLI}) allows a user to communicate with a computer program by entering lines of text, the \emph{command lines}. Although some have graphical capabilities (src), this thesis focuses on purely character-based interfaces.

Commonly, interaction with a \textsc{CLI} consists of three phases:

\begin{enumerate}
    \item The program writes a \emph{prompt}, which a special character sequence that signals that the program now accepts a command.
    \item The user composes a command line, often using several editing capabilities the CLI offers. To tell the program to execute the command, he uses a \emph{return} character. (rlly?)
    \item The program executes the command and prints a response. Sometimes, the execution is interactive (ref reaktive systeme) and does not return until the user tells the program to. After the command has finished, the first phase starts again.
\end{enumerate}

Here is an example of one iteration of these phases.\footnote{The \textsc{CLI} in this case is an \emph{Interactive Ruby Shell}.} The \texttt{>\->} is the prompt, the \texttt{2**10} is the command line the user entered, and the \texttt{1024} is the command's output:

\begin{lstlisting}
>> 2**10
1024
\end{lstlisting}

\section{Terminal}

In the past, a \emph{computer terminal} was a device for communication with mainframe computers. They read text from the user via a keyboard and displayed the computer's output, first on paper, later on a screen. (src: wiki)

Here, when we use the term \emph{terminal}, we mean a modern \emph{terminal emulator}, a program that resembles a terminal within an otherwise graphical environment. Inside these terminal emulators, \textsc{CLI}s can be used.

Terminals communicate through sequential streams of characters: They receive characters from a program to be displayed, and they receive characters from the user's keyboard, which they send back to the program.

\subsection{Escape codes}

A classical computer terminal was the \textsc{VT100}, introduced 1978 by \textsc{Digital Equipment Corporation}. Nowadays, modern terminal emulators mimic its behaviour. The device had a mechanism for doing graphical output: By sending special character sequences, the terminal performed special actions like moving the cursor, deleting characters on the screen or turning graphical modes (underlining, different colors) on and off. The \textsc{VT100} supported the escape sequences defined in ANSI X3.64 (ref), also called the \emph{ANSI escape sequences}.

(...)

\subsection{Readline}

To allow comfortable text input, and to enable functions like command line editing or a command history, many (quot) programs use a library called \emph{readline}. This library has some default keybindings, of which we use the following:

(come from emacs)

\begin{table}[tb]
    \begin{tabular}{r|r}
        Key combination & effect \\
        \hline
        Ctrl + U & delete line \\
    \end{tabular}
    \caption{Readline key combinations}
\end{table}

\section{Targets}
\label{sec:targets}

The \emph{Nut Shell} is designed to support many different command line interfaces.

Examples of command line interfaces are bash, irb, python, ghci, ... When we talk about one of these programs, we call it the \emph{Nut Shell}'s current \emph{target}.

To be a target for the \emph{Nut Shell}, a command line program needs to have these features:

\begin{itemize}
    \item A freely customizable prompt. (2nd?)
    \item Readline-like keybindings. Mandatory are the following three key combinations:
        \keys{\ctrl+E} has to jump to the end of the line

        \keys{\ctrl+U} has to delete the momentarily entered line and puts it in an internal buffer
        
        \keys{\ctrl+Y} has to re-insert the content of this buffer
\end{itemize}

All of the command line programs mentioned above have those features and thus can be used as \emph{targets}.

\chapter{Parsing the Command Line}

In this thesis, we treat the target command line process as a black box having input and output streams of Unicode characters. To enable the \emph{Nut Shell} to check conditions on the user's interaction, it needs to parse the output accordingly. The interesting parts in this context are the following three, which correspond to the phases described in \cref{sec:cli}:

\begin{enumerate}
    \item Which prompt is displayed to the user?
    \item Which command does he enter?
    \item What is the output of this command?
\end{enumerate}

The purpose of the framework's lowest-level component, the \emph{command line parser}, is to recognize these different parts of the interaction in a running command line process. To do this, it wraps around the process, watches and modifies its input and output.

The mechanisms presented in this section work for arbitrary command line targets, and thus provide a common interface to them.

The main idea here is to use special \emph{markers}, unique character sequences that do not appear in normal command line interaction, to annotate the output of the process. The different components can then be recognized by a parser.

\section{Recognizing the prompt}

To recognize the prompt is the easiest part. As the prompt of the target process can be changed (by definition, see \cref{sec:targets}), the \emph{Nut Shell} configures the prompt to start and end with a marker. In the output, the prompt can now be identified easily.

This approach has a downside: If the user tries to change the prompt himself, the system will break. To avoid this, ?

\section{Recognizing the command}

While the user edits the command line, he may use Readline's key bindings or other shell builtin key combinations. These make it hard to recognize which command he entered, as parts of the entered characters could have been deleted or otherwise have been changed. To solve this, we use a mechanism to repeat the entered line before it is sent.

All targets support (by definition, through Readline) the keyboard shortcuts \keys{\ctrl+U}, which deletes the momentarily entered command and puts it in an internal buffer and \keys{\ctrl+Y} to re-insert the content of the buffer. The parser waits for the user to send a Return character and then sends the sequence

\begin{quote}
    \keys{\ctrl+U} marker \keys{backspace} \keys{\ctrl+Y} marker \keys{backspace} \keys{\return}
\end{quote}

to the underlying process. The result is that the entered command is appearing in the output cleanly framed by the two markers, whereas the output looks the same to the user.

\Cref{tab:cmdmarking} demonstrates this technique. The first column lists the user's keystrokes, the second one contains the characters sent to the process, the third one contains the output of the process, and the final one shows the current content of the terminal.

\begin{table}[tb]
    \centering
    \caption{Example of the command marker technique.}
    \label{tab:cmdmarking}
    \begin{tabular}{l|l|l|l}
        Keystrokes & Input & Output & Screen content \\
        \hline
        & & \texttt{>>␣} & \texttt{>>␣\cursor} \\
        \keys{1} \keys{-} \keys{1} & \texttt{1-1} & \texttt{1-1} & \texttt{>>␣1-1\cursor} \\
        \keys{\arrowkeyleft} & \texttt{\escape{[}[D} & \texttt{\escape{H}} & \texttt{>>␣1-\invert{1}} \\
        \keys{backspace} & \texttt{\escape{H}} & \texttt{\escape{H}} & \texttt{>>␣1\invert{-}1} \\
        & & \texttt{\escape{[}[1P} & \texttt{>>␣1\invert{1}} \\
        \keys{{+}} & \texttt{+} & \texttt{+} & \texttt{>>␣1+\cursor} \\
        & & \texttt{1} & \texttt{>>␣1+1\cursor} \\
        & & \texttt{\escape{H}} & \texttt{>>␣1+\invert{1}} \\
        \keys{\return} & \texttt{\escape{E}} & \texttt{\escape{[}[C} & \texttt{>>␣1+1\invert{ }} \\
        & \texttt{␣} & \texttt{␣} & \texttt{>>␣1+1␣\invert{ }} \\
        & \texttt{\escape{U}} & \texttt{\escape{H}\escape{H}\escape{H}\escape{H}} & \texttt{>>␣\invert{1}+1␣} \\
        & & \texttt{\escape{[}[K} & \texttt{>>␣\invert{ }} \\
        & \texttt{\{marker\}} & \texttt{\{marker\}} & \texttt{>>␣\{marker\}\invert{ }} \\
        & \texttt{\escape{H}} & \texttt{\escape{H}\escape{[}[K} & \texttt{>>␣\invert{ }} \\
        & \texttt{\escape{Y}} & \texttt{1+1␣} & \texttt{>>␣1+1␣\invert{ }} \\
        & \texttt{\{marker\}\escape{H}} & \texttt{\{marker\}\escape{H}\escape{[}[K} & \texttt{>>␣1+1␣\invert{ }} \\
        & \texttt{\escape{H}} & \texttt{\escape{H}\escape{[}[K} & \texttt{>>␣1+1\invert{ }} \\
    \end{tabular}
\end{table}

The full output of this sequence is (...), and by taking the characters between the markers and discarding the first two (for deletion of the marker itself) and the final one (the space) we get the exact command line the user wishes to send.

\section{Interactivity}

The \textsc{CLI} can start other programs which run in the foreground; that is, wait for the user to enter text. These programs are called \emph{interactive}. Examples are text editors or pagers, that show a long text and allow the user to scroll up and down. With this kind of prompt you cannot wait for the command to finish, but you have to show the output to the user beforehand, so they can interact with it.

The parser solves this by using a timer: If a command runs longer than (x) milliseconds; that is, when the parser waits longer than that for a marker, it switches to \emph{interactive mode}, which shows the output directly.

\section{Multi line commands}

The are \textsc{CLI}s which recognize that a command is incomplete. In this case, they do not send the command, but give the user the possibility to complete it. Usually, the CLI displays a second, special prompt in this case. The parser inserts markers there, too, so that it can be differeniated from a normal prompt.

After the previously described enter handling, the parser looks at the next character - if it is a secondary-prompt-marker, it falls back to command-editing mode. In the end all such part-command-lines are appended to get the full command.

\section{Architecture}

Putting it all together:

(Component diagram)

(ref: ebnf)

%blabla \synt{command} blabla \lit{bla}

The output of the process consists of three phases: The prompt with the markers, the composing of the command (which can include escape sequences for editing, or can consist of several lines), and the command's output:

\begin{ebnf}
Output = { PromptWithMarkers CommandComposing CommandOutput } .
\end{ebnf}
%
The prompt begins and ends with markers, which must not appear in between:

\begin{ebnf}
PromptWithMarkers = marker Prompt marker
Prompt = { NonMarkerCharacter }
NonMarkerCharacter = ? everything but marker/marker2 ?
\end{ebnf}
%
In the composing phase, the user enters a command of one or more lines. Each line forms a composing sequence, followed by a repetion through the technique mentioned above. If the command has more than one lines, the following lines each are preceeded by a secondary prompt:

\begin{ebnf}
CommandComposing = ComposingAndEcho [ { Prompt2WithMarkers ComposingAndEcho } ]
Prompt2WithMarkers = marker2 Prompt marker2
\end{ebnf}
%
The composing sequence itself has two phases: In the first one, the actual line composing takes place. In the second one, the current line is deleted and reprinted. The latter phase happens as described in (ref) above: The line is deleted, a marker is sent and deleted, the command is printed, a second marker is printed and deleted, and a newline is sent:

\begin{ebnf}
ComposingAndEcho = LineComposing CommandEcho
LineComposing = { NonMarkerCharacter }
CommandEcho = Deletition Marker Deletion Command Marker Deletion "\r"
Deletition = { DeletitionCharacter }
DeletitionCharacter = ^W | ^K | ...
\end{ebnf}
%
Finally, the command output simply consists of non marker characters:

\begin{ebnf}
CommandOutput = { NonMarkerCharacter }
\end{ebnf}

%marker ::= '☃'
%marker2 ::= '★'

(example)

\chapter{The \emph{nutsh} Language}

To enable authors to create \emph{Nut Shell} tutorials quickly, we created a new domain-specific programming language (\textsc{DSL}). The term \emph{nutsh} is a contraction of “Nut Shell” and also serves as the filename extension.

Files written in the \emph{nutsh} language represent self-contained teaching unit, “lessons”.

Lesson files should be as easy to read and to write as possible. We decided to use a syntax close to the ones potential users will already know; that is, regular expressions and for the rest a syntax similar to Go. C users will also feel at home. The language contain syntactic structures that support often-used semantical statements. The language provides mechanisms to reuse code snippets to minimize redundance.

The language is string-based, the only data type is a string of Unicode characters, this keeps the language minimal. \emph{nutsh} does not have variables, which makes the language functional.

\section{Specification}

In this section, the language's lexical and syntactical elements are specified in \textsc{EBNF} as defined in \cref{sec:ebnf}. Overall, \emph{nutsh}'s syntax is inspired by Google's Go (ref), for example the definition of string literals and the syntax of \texttt{if} clauses.

\subsection{Lexical elements}

\minisec{Comments}

\emph{nutsh} has two types of comments, as they exist in C-like languages: \emph{Line comments} start with \texttt{//} and stop at the end of the line, \emph{block comments} start with \texttt{/*} and end with \texttt{*/}. Comments act as white space and are ignored otherwise.

\minisec{White space}

Whites space (newlines, carriage returns, tab and space characters) seperates tokens but has no further meaning.

\minisec{Identifiers}

Identifiers serve as names that can be used for functions. An identifier is a nonempty sequence of alphanumeric characters.

\begin{ebnf}
Identifier = letter { letter } .
\end{ebnf}

\minisec{Keywords}

\emph{nutsh} uses the following keywords, which may not be used as identifiers:

\begin{quote}
    \texttt{break}\hspace{0.5em}
    \texttt{def}\hspace{0.5em}
    \texttt{else}\hspace{0.5em}
    \texttt{if}\hspace{0.5em}
    \texttt{prompt}\hspace{0.5em}
    \texttt{return}
\end{quote}

\minisec{Operators and delimiters}

The following character sequences have special meanings in \emph{nutsh}:

\begin{quote}
    \texttt{=\~}\hspace{1em}
    \texttt{==}\hspace{1em}
    \texttt{||}\hspace{1em}
    \texttt{,}\hspace{1em}
    \texttt{!}\hspace{1em}
    \texttt{(}\hspace{1em}
    \texttt{)}\hspace{1em}
    \texttt{\{}\hspace{1em}
    \texttt{+}\hspace{1em}
    \texttt{\}}\hspace{1em}
    \texttt{\&\&}
\end{quote}

\minisec{String Literals}

There are two types of string literals, which have the same syntax as in Go: \emph{raw string literals} and \emph{interpreted string literals}. Raw string literals are enclosed with back quotes (\texttt{\`}). They may contain any character except the back quote; the characters are interpreted literally. Interpreted string literals are enclosed with double quotes (\texttt{"}) and may contain backslash escapes.

\begin{ebnf}
string = raw_string | interpreted_string .
raw_string = "`" { unicode_char } "`" .
interpreted_string = `"` { unicode_char | byte_value } `"` .
\end{ebnf}

\subsection{Expressions}

\minisec{String Expressions}

The \emph{nutsh} language makes strong use of strings (\texttt{"foo"}). String expressions can be concatenated (\texttt{"foo"+"foo"} has the same value as \texttt{"foofoo"}) and be checked for equality (\texttt{"foo" == "foo"}). Additionally, one can check whether a string matches a regular expression (\texttt{"foo" =~ "f.."}).\footnote{Using the syntax of the regular expression parsing library \emph{RE2} as described here: \url{https://code.google.com/p/re2/wiki/Syntax}} Every string can be interpreted as a truth value, which is \emph{false} for an empty string and \emph{true} otherwise. The common logic operators (\texttt{!} for \emph{not}, \texttt{\&\&} for \emph{and}, and \texttt{||} for \emph{or} are defined accordingly. They return the (arbitrary) nonempty string \texttt{"true"} for a truth value.

\begin{ebnf}
StringExpression =
        string | Call | StringExpression Operator StringExpression |
        "!" StringExpression | "(" StringExpression ")" .

Operator = "+" | "==" | "=~" | "&&" | "||" .
\end{ebnf}

\minisec{Operator precedence}

String concatenation binds strongest, followed by the two comparison operators, logical \emph{and}, and finally logical \emph{or}. Operators bind from left to right---\texttt{a OP b OP c} has the same meaning as \texttt{(a OP b) OP c}.

\minisec{Calls}

\emph{nutsh} knows \emph{functions}, which can be called by specifying the correct number of arguments. If a function takes no arguments, the brackets can be omitted. As a special case, a string on its own also acts as a function call, see the following section.

\begin{ebnf}
Call = identifier [ "(" [ StringExpressions ] ")" ] |
        string .
StringExpressions = StringExpression { "," StringExpression } .
\end{ebnf}

\subsection{Built-in functions}

A central command is the output of explanation text. This text will be displayed indented and highlighted in a different color.

\begin{nutsh}
say("This is explaining text.")
\end{nutsh}
%
Because this command is used so often, it can be abbreviated to:

\begin{nutsh}
"This is the short form."
\end{nutsh}
%
To execute a command in the target process, you use \texttt{run()}. The value of this statement is the command's output.

\begin{nutsh}
run("1+1")
\end{nutsh}

\subsection{Statements}
\label{sec:statements}

\minisec{Blocks}

A \emph{block} is a sequence of lines:

\begin{ebnf}
Block = "{" { Line } "}" .
Line = IfStatement | PromptStatement | State | Call .
\end{ebnf}

\minisec{If statements}

If the conditional expression of an \texttt{if} statement evaluates to \emph{true}, the first block is evaluated, otherwise the (optional) second block. Like in Go, there are no brackets around the condition.

\begin{ebnf}
IfStatement = "if" StringExpression Block ( "else" Block ) .
\end{ebnf}
%
This example checks a string for equality with itself and prints an according message:

\begin{nutsh}
if "test" == "test" {
    "Everything is OK."
} else {
    "Wait, what?"
}
\end{nutsh}

\minisec{Prompt statements}

The prompt statement is a central element of \emph{nutsh}'s syntax. It has the semantic of an endless loop, in which a command is read from the user at the beginning of each pass. It can be left with a \texttt{break} statement.

\begin{ebnf}
PromptStatement = "prompt" Block .
\end{ebnf}
%
There are two builtin functions called \texttt{command} and \texttt{output}, that correspond to the user's latest command and its output. When no prompt has occurred yet, they return empty strings.

In this example, the user is asked to enter a command that has the output “42”. When he obeys, the prompt loop is left with a \texttt{break} statement, otherwise he has to try again:

\begin{nutsh}
"Please calculate the product of 6 and 7."

prompt {
    if output == "42" {
        break
    } else {
        "Please try again."
    }
}

"Well done!"
\end{nutsh}

\minisec{Function definition}

To define a new function, the \texttt{def} keyword is used, followed by the name of the function, optional arguments and a block. The brackets around the arguments can be omitted if a function has no arguments:

\begin{ebnf}
Definition = "def" identifier [ Arguments ] Block .
Arguments = "(" [ identifier { "," identifier } ] ")" .
\end{ebnf}
%
As an example, we define a function that prints its argument twice:

\begin{nutsh}
def say_twice(text) {
    say(text)
    say(text)
}

say_twice("Hey!")
\end{nutsh}

\minisec{Nesting statements}

Sometimes, the same set of conditions needs to be checked for a group of prompt statements. In this case, nesting statements can be used. They consist of one or more function calls, followed by a block.

(ref: uml)

\begin{ebnf}
State = Calls Block .
Calls = Call { "," Call } .
\end{ebnf}
%
At each pass of a prompt loop, after the command has been read from the user, the specified parent functions are called. There can be more than one level of nesting -- the outmost parent functions are called first.

In this example, a function is defined that prints a message when the user enters a command that contains “help”. For two \texttt{prompt} statements, a nesting statement is defined to call this function. Now every time the user enters a command in these two prompt loops, the function is called.

\begin{nutsh}
def respond_to_help {
    if command =~ "help" {
        "Sorry, you're on your own."
    }
}

respond_to_help {
    prompt {
        // break condition ...
    }
    prompt {
        // break condition ...
    }
}
\end{nutsh}
%
(larger example?)

%\begin{nutsh}
%def stay_in(dir) {
%    if ! run("pwd") =~ "^"+dir {
%        say("Please come back to `"+dir+"`!")
%        prompt {
%            if run("pwd") =~ "^"+dir {
%                break
%            }
%        }
%        "OK, let's continue."
%    }
%}
%
%def help {
%    if command =~ "help" {
%        "Don't panic!"
%    }
%}
%
%run("cd /tmp")
%
%stay_in("/tmp"), help {
%    "How late is it?"
%    prompt {
%        if command == "date" {
%            break
%        }
%    }
%
%    "And who are you?"
%    prompt {
%        if command == "whoami" {
%            break
%        }
%    }
%}
%\end{nutsh}

\subsection{Top level structure}

A \emph{nutsh} file consists of several of function definitions and other \texttt{Line}s (\texttt{if}-, \texttt{prompt}- and nesting statements in addition to \emph{calls}, see \cref{sec:statements}). Function definitions can only appear at the top level to avoid redefinitions in different scopes, which would lead to name masking problems and more complexity.

\begin{ebnf}
Lesson = { Definition | Line } .
\end{ebnf}

\section{Interpreting}

After parsing, we have a \emph{syntax tree} representation of the lesson. The interpreter can now travel through the tree and do its thing!

When a function definition is encountered, 

(State)

(Function stack)

\section{Automated testing}

As the author of a tutorial, one wants to verify that all the lessons work correctly. The framework provides a function for automated testing of correctness, so one does not have to enter all the required commands by hand.

To help with this, the framework provides the builtin function \texttt{expect}, which expresses the assumption of the author that if a user were to enter the supplied argument as a command in the innermost surrounding \texttt{prompt} statement, the \texttt{expect} statement would be reached.

In this example, the user is asked to reverse a given string. The \texttt{expect} lines give two different ways to achieve it---both should work. There's also an \texttt{expect} command that should \emph{not} lead to an evaluation of the first block:

\begin{nutsh}
run("text = 'stressed'")
"Reverse the content of `text` and save it in `text2`!"
prompt {
    if test("text2 == 'desserts'") {
        "You did it!"
        expect("text2 = text.reverse")
        expect("text.reverse!; text2 = text")
        break
    } else {
        expect("text2 = 'somethingdifferent'")
    }
}
\end{nutsh}

The testing algorithm first collects all \texttt{expect} statements and creates a reference for each of them in the nearest \texttt{prompt} statement around the statement.

It then starts interpreting the file like normally, but when a \texttt{prompt} statement is encountered, instead of querying the user for a command, one of the unreached associated \texttt{expect} commands is used. When the respective \texttt{expect} statement is reached, the statement is marked as \emph{reached}. When the end of the prompt loop is reached, and the \texttt{expect} has not been reached, an error is printed and the test is aborted. At the end of the file, if there are any unreached \texttt{expect}s left, the lesson is restarted.

By convention, when a prompt is encountered whose expects are all reached, the first one is used. Thus, the first expect in each prompt should be one that leads to a \texttt{break} statement to ensure the testing algorithm terminates.

(c0/c1)...

\chapter{Application and Evaluation}

To find out whether the teaching method provided by the \emph{Nut Shell} has any advantages compared to traditional teaching methods, we created an example tutorial and conducted a two-week course with a subsequent survey.

\section{Setting}

The \textit{Braunschweig University of Technology} has been organizing preparatory Computer Science courses for freshman students since 2003. This course teaches how to use UNIX-like operating systems and accompaning tools for program creation.

Until now, these topics were tought by handing out exercises on paper, which the students could work on in computer pools. For support, student assistants were provided, with about one assistant per 25 students.

In the fall semester 2013--2014, 150 students enrolled in the course. For this study, the students were split into two groups: Two thirds of the students were randomly selected to use the Nut Shell, the remaining one third worked with the previously used exercises on paper. The groups worked in two separate rooms. Each day, there were three time slots of 75 minutes each, to which the students were assigned in equal parts. The course spanned over eight days, not including a weekend and a day off.

The course roughly covers the these topics: The \textsc{UNIX} file system and how to manipulate it; various text editors like Vim, Emacs, and Gedit; process management; command line tools for text manupulation like \texttt{grep}, \texttt{sort}, or \texttt{patch}; various shell mechanism like output redirection and the command history; shell scripts; automatition with Makefiles; accessing remote servers with \textsc{SSH}; typesetting documents with \LaTeX; understanding and repairing programs written in \textit{Java}; and version control with \textit{Git}.

The newly created \textit{Nut Shell} tutorial kept these topics and their order, but presented them in a different fashion.

For an example of such a tutorial, refer to \cref{sec:nutshexample}.

The material was divided into 30 invidiual lessons that covered one topic, respectively. In total, the tutorial contains 2875 lines of \textit{nutsh} code. In total, it took about 40 hours to write and test the lessons.

\section{Style}

The basic structure in the tutorial when introducing new concepts is the following: First, a general problem is stated. The method or tool for solving these problem instances is presented with a simple example, where the user is guided exactly what to do. After that follow several problems the user has to solve on his own of increasing difficulty. Finally, some advanced concepts and ideas are touched, and the user is given some free room to experiment with those. A clear signal is communicated the user can use to continue.

Often, goals are stated but how to achieve it is up to the user. This has to be realized by testing against \texttt{output} and \texttt{run()} statements. At several occasions, the user can choose among several paths to continue or can determine in which order to learn about several topics. These structures are supposed to give the user a feeling of autonomy and control.

For better illustration and for a more entertaining experience, the lessons introduce several real-world metaphors for abstract concepts. For example, in a lesson about the compression of files, the user is confronted with a directory named \textit{fridge} and a large file named \textit{elephant} and is asked to put the elephant in the fridge.\footnote{This is a reference to the old joke “How do you put an elephant into a fridge? -- Open the fridge, put in the elephant, and close the door.”} To complete this task, the file has to be compressed.

\section{Survey}

After the sixth day, an online survey was conducted whithin both groups. In the first part, the following general questions were asked (in German):

\begin{itemize}
    \item What is your course of studies?
    \item Did you use the \emph{Nut Shell} or the paper exercises?
    \item On a range from 1 (not at all) to 10 (entirely), how much do you agree to the following statements?
        \begin{enumerate}
            \item I had previous knowledge about the command line.
            \item The tutorial was fun.
            \item I learned a lot in the tutorial.
            \item The exercises were too hard.
            \item I had enough time to complete the exercises.
            \item I think the material is relevant for my further education.
            \item I would recommend the tutorial to others.
        \end{enumerate}
    \item How many times did you have to ask for help per day?
\end{itemize}

The second part of the survey was a quiz with 11 questions about different topics of the tutorial, in an attempt to quantify how much the participants learned. The following questions were provided by a person who was uninvolved with and unaware of the content of the \emph{Nut Shell} lessons to avoid a bias which could have led to asking questions we knew the Nut Shell explained well. For evaluation, each answer was marked with either 0 points (no or wrong answer), 0.5 points (correct parts), or 1 points (complete and correct answer).

\begin{enumerate}
    \item How do you create the directory \texttt{abc.txt}?
    \item How do you copy the file \texttt{abc.txt} to the directory \texttt{xyz}?
    \item How can you obtain more information about the command \texttt{mv}?
    \item Name at least two ways to look at the content of the file \texttt{abc.txt}.
    \item What do you use the command \texttt{ln} for?
    \item Output all lines of the file \texttt{abc.txt} that contain the Text "Hallo".
    \item What is the variable \texttt{PS1} used for?
    \item What do you use \texttt{>} and \texttt{>>} for and how do they differ?
    \item How dou you archive and compress all files with the ending "123" in the current directory?
    \item What is the file \texttt{~/.bashrc} used for?
    \item You don't want to type \texttt{ls -alR} all the time, but create a short hand form. Which possibilities do you have and what is the corresponding command?
    \item What are pipes used for and how do you use them? Write an example command.
\end{enumerate}

\section{Results}

For the first part, there were 64 answers in total. 52 of the participants specified they had used the \emph{Nut Shell}, 11 of them the exercises. \Cref{fig:general} juxtaposes the answers to the general questions in both groups in the form of a box plot. The circle marks the answer's median of a question, the box contains 50\% of the answers, the whiskers reach from the minimal to the maximal score. According to the participants, the \emph{Nut Shell} users had significantly more fun and had the impression of having learned more than the paper exersice users. While there is slight evidence that the \emph{Nut Shell} users found the course easier, had less time, and thought of the topics more relevant, these differences are not statistically relevant.

\begin{figure}[p]
    \begin{tikzpicture}[trim axis left, trim axis right]
        \begin{axis}[
                boxplotcompare style,
                ytick={1,2,3,4,5,6,7},
                yticklabels={Piror knowledge, Fun, Learned a lot, Too hard, Enough time, Relevant, Recommend},
                boxplot,
                y dir=reverse,
                height=\textheight,
                width=\textwidth,
                xmin=0.5,
                xmax=10.5,
                xmajorgrids,
                ymin=0,
                ymax=8,
            ]

            \addlegendimage{area legend, fill=white, draw=black}
            \addlegendentry{Paper};
            \addlegendimage{area legend, fill=gray, draw=black}
            \addlegendentry{Nut Shell};

            \addplot[
                forget plot,
                rshift,
                boxplot prepared={
                    lower whisker =1,
                    lower quartile=1,
                    median        =2,
                    upper quartile=4.25,
                    upper whisker =10,
                },
            ] coordinates {};
            \addplot[
                lshift,
                boxplot prepared={
                    lower whisker =1,
                    lower quartile=1,
                    median        =1.5,
                    upper quartile=2.25,
                    upper whisker =3,
                },
            ] coordinates {};

            \addplot[% fun
                forget plot,
                rshift,
                boxplot prepared={
                    lower whisker =3,
                    lower quartile=7,
                    median        =9,
                    upper quartile=10,
                    upper whisker =10,
                },
            ] coordinates {};
            \addplot[
                lshift,
                boxplot prepared={
                    lower whisker =6,
                    lower quartile=7,
                    median        =8,
                    upper quartile=8,
                    upper whisker =10,
                },
            ] coordinates {};

            \addplot[% learn
                forget plot,
                rshift,
                boxplot prepared={
                    lower whisker =5,
                    lower quartile=8,
                    median        =9,
                    upper quartile=9.25,
                    upper whisker =10,
                },
            ] coordinates {};
            \addplot[
                lshift,
                boxplot prepared={
                    lower whisker =5,
                    lower quartile=7,
                    median        =7.5,
                    upper quartile=9,
                    upper whisker =10,
                },
            ] coordinates {};

            \addplot[% too hard
                forget plot,
                rshift,
                boxplot prepared={
                    lower whisker =1,
                    lower quartile=3,
                    median        =4,
                    upper quartile=5,
                    upper whisker =9,
                },
            ] coordinates {};
            \addplot[
                lshift,
                boxplot prepared={
                    lower whisker =2,
                    lower quartile=2.75,
                    median        =4.5,
                    upper quartile=5.25,
                    upper whisker =7,
                },
            ] coordinates {};

            \addplot[% enough time
                forget plot,
                rshift,
                boxplot prepared={
                    lower whisker =3,
                    lower quartile=7,
                    median        =9,
                    upper quartile=10,
                    upper whisker =10,
                },
            ] coordinates {};
            \addplot[
                lshift,
                boxplot prepared={
                    lower whisker =3,
                    lower quartile=8.75,
                    median        =10,
                    upper quartile=10,
                    upper whisker =10,
                },
            ] coordinates {};

            \addplot[% relevant
                forget plot,
                rshift,
                boxplot prepared={
                    lower whisker =5,
                    lower quartile=7,
                    median        =8,
                    upper quartile=9,
                    upper whisker =10,
                },
            ] coordinates {};
            \addplot[
                lshift,
                boxplot prepared={
                    lower whisker =5,
                    lower quartile=6.75,
                    median        =7.5,
                    upper quartile=8.25,
                    upper whisker =10,
                },
            ] coordinates {};

            \addplot[% recommend
                forget plot,
                rshift,
                boxplot prepared={
                    lower whisker =4,
                    lower quartile=8,
                    median        =9,
                    upper quartile=10,
                    upper whisker =10,
                },
            ] coordinates {};
            \addplot[
                lshift,
                boxplot prepared={
                    lower whisker =6,
                    lower quartile=7.75,
                    median        =9,
                    upper quartile=10,
                    upper whisker =10,
                },
            ] coordinates {};
        \end{axis}
    \end{tikzpicture}
    \centering
    \caption{Answers to general questions}
    \label{fig:general}
\end{figure}

\Cref{fig:help} shows the answer to the question regarding how many times per day the participant needed support from a student assistant. Clearly, the \emph{Nut Shell} users needed less help.

\begin{figure}[tb]
    \begin{tikzpicture}[trim axis left, trim axis right]
        \begin{axis}[
                boxplotcompare style,
                ytick={1},
                yticklabels={help/day},
                boxplot,
                y dir=reverse,
                height=0.32\textwidth,
                width=\textwidth,
                xmin=-0.5,
                xmax=10.5,
                xmajorgrids,
                ymin=0.2,
                ymax=1.5,
            ]

            \addlegendimage{area legend, fill=white, draw=black}
            \addlegendentry{Paper};
            \addlegendimage{area legend, fill=gray, draw=black}
            \addlegendentry{Nut Shell};

            \addplot[
                forget plot,
                rshift,
                boxplot prepared={
                    lower whisker =0,
                    lower quartile=1,
                    median        =1.5,
                    upper quartile=3,
                    upper whisker =10,
                },
            ] coordinates {};
            \addplot[
                lshift,
                boxplot prepared={
                    lower whisker =1,
                    lower quartile=2,
                    median        =4,
                    upper quartile=5.5,
                    upper whisker =10,
                },
            ] coordinates {};
        \end{axis}
    \end{tikzpicture}
    \centering
    \caption{How many times did you have to ask for help per day?}
    \label{fig:help}
\end{figure}

\Cref{fig:quiz} shows the quiz scores. The assignment users achieved a slightly higher score.

\begin{figure}[tb]
    \begin{tikzpicture}[trim axis left, trim axis right]
        \begin{axis}[
                boxplotcompare style,
                ytick={1},
                yticklabels={help/day},
                boxplot,
                y dir=reverse,
                height=0.32\textwidth,
                width=\textwidth,
                xmin=-0.5,
                xmax=10.5,
                xmajorgrids,
                ymin=0.2,
                ymax=1.5,
            ]

            \addlegendimage{area legend, fill=white, draw=black}
            \addlegendentry{Paper};
            \addlegendimage{area legend, fill=gray, draw=black}
            \addlegendentry{Nut Shell};

            \addplot[
                forget plot,
                rshift,
                boxplot prepared={
                    lower whisker =3,
                    lower quartile=5,
                    median        =6,
                    upper quartile=7.5,
                    upper whisker =12,
                },
            ] coordinates {};
            \addplot[
                lshift,
                boxplot prepared={
                    lower whisker =3,
                    lower quartile=5.75,
                    median        =7,
                    upper quartile=8.375,
                    upper whisker =9,
                },
            ] coordinates {};
        \end{axis}
    \end{tikzpicture}
    \centering
    \caption{Points that the participants got in the quiz}
    \label{fig:quiz}
\end{figure}

\Cref{fig:participants} shows the number of participants per day in both groups.

\begin{figure}[tb]
    \begin{tikzpicture}[trim axis left, trim axis right]
        \pgfplotstableread{ % Read the data into a table macro
            Label	Slot1	Slot2	Slot3	a	b	c
            1	29	26	25	15	15	15
            2	25	28	24	9	15	5
            3	30	25	16	9	10	15
            4	24	22	16	9	12	5
            5	25	19	11	6	10	1
            6	0	0	0 	0	0	0
            7	0	0	0 	0	0	0
            8	23	28	12	9	11	2
            9	25	23	19	9	6	0
            10	0	0	0 	0	0	0
            11	25	20	6 	10	1	0
        }\datatable

        \begin{axis}[
                width=\textwidth,
                ybar stacked,
                ymin=0,
                xmin=-1,
                xmax=11,
                xtick=data,
                xticklabels from table={\datatable}{Label},
                xlabel=Day,
                ylabel=Participants,
                ymajorgrids,
            ]

            \addlegendimage{area legend, fill=white, draw=black}
            \addlegendentry{Paper};
            \addlegendimage{area legend, fill=gray, draw=black}
            \addlegendentry{Nut Shell};

            \addplot [fill=gray, bar shift=-.2cm] table [y=Slot1, x expr=\coordindex] {\datatable};    % Plot the "First" column against the data index
            \addplot [fill=gray, bar shift=-.2cm] table [y=Slot2, x expr=\coordindex] {\datatable};
            \addplot [fill=gray, bar shift=-.2cm] table [y=Slot3, x expr=\coordindex] {\datatable};

            \resetstackedplots

            \addplot [fill=white, bar shift=.2cm] table [y=a, x expr=\coordindex] {\datatable};
            \addplot [fill=white, bar shift=.2cm] table [y=b, x expr=\coordindex] {\datatable};
            \addplot [fill=white, bar shift=.2cm] table [y=c, x expr=\coordindex] {\datatable};
        \end{axis}
    \end{tikzpicture}
    \centering
    \caption{Number of participants per day}
    \label{fig:participants}
\end{figure}

\Cref{fig:meta} shows the answers to the \emph{Nut Shell} related questions.

\begin{figure}[tb]
    \begin{tikzpicture}[trim axis left, trim axis right]
        \begin{axis}[
                boxplotcompare style,
                ytick={1,2,3,4},
                yticklabels={Good explanations, Helpful tips, Good exercises, Would use again},
                boxplot,
                y dir=reverse,
                height=0.3\textheight,
                width=\textwidth,
                xmin=0.5,
                xmax=10.5,
                xmajorgrids,
                ymin=0,
                ymax=5,
            ]

            \addplot[%explanation
                fill=gray,
                boxplot prepared={
                    lower whisker =5,
                    lower quartile=8,
                    median        =9,
                    upper quartile=10,
                    upper whisker =10,
                    box extend=0.6,
                },
            ] coordinates {};
            \addplot[%help
                fill=gray,
                boxplot prepared={
                    lower whisker =2,
                    lower quartile=5,
                    median        =7,
                    upper quartile=8,
                    upper whisker =10,
                    box extend=0.6,
                },
            ] coordinates {};
            \addplot[%exercises
                fill=gray,
                boxplot prepared={
                    lower whisker =4,
                    lower quartile=7,
                    median        =9,
                    upper quartile=10,
                    upper whisker =10,
                    box extend=0.6,
                },
            ] coordinates {};
            \addplot[%again
                fill=gray,
                boxplot prepared={
                    lower whisker =5,
                    lower quartile=8,
                    median        =10,
                    upper quartile=10,
                    upper whisker =10,
                    box extend=0.6,
                },
            ] coordinates {};
        \end{axis}
    \end{tikzpicture}
    \centering
    \caption{Answers to \emph{Nut Shell} related questions}
    \label{fig:meta}
\end{figure}

\section{Discussion}

The small number of participants that were left after day 8 a problem. The results are warped, as just those participants who had fun and learned something stayed, which explains why the scores are relatively close to each other.

That is why we evaluated the loss of participants over time. In this case, 63.8\% of the \emph{Nut Shell} users stayed until the last day. Of the exercise sheet users, only 24.4\% stayed.

\chapter{Conclusions}

(Discussion of survey results)

\chapter{Limitations and Future Directions}

Right now, typing errors can be catched by defining some command-rules by hand. The expect-Statements could be used to automate this detection of typing errors by applying (algorithm).

    (Simplified prompt syntax)

    (Lesson dependency tree)

    (goal-oriented syntax)

    (automated feedback for authors through logging)

    I plan to extend the Nut Shell further and release it under an Open Source license to allow others to benefit from it. During the preparatory course, a student told us he would like to use the \emph{Nut Shell} to teach the command line to pupils at his old school.

\cleardoublepage
\part*{Appendix}
\appendix

\chapter{Example Lesson}
\label{sec:nutshexample}

(nutsh source code)

(Execution output)

\chapter{Implementation}

\section{Used technologies}

The framework has been implemented in Google Go (src), a compiled, statically typed language, which is seen by many as a modern successor to C.

For emulating a terminal, the \texttt{pty} package was used.
(ref)

To conduct the survey, we used the open source software \emph{Limesurvey}.

\section{Parsing}

To parse the token stream into a parse tree, we used \textsc{YACC}. \textsc{YACC} is a $LALR(1)$ parser generator that takes a list of token types, a grammar description and a operator precedence declaration and generates a method that takes tokens from the lexer and parses them. Go comes with its own YACC implementation (ref).

(ref: http://dinosaur.compilertools.net/yacc/)

\section{High-level design}

(Diagram: Package diagram)

\section{Command line tool}

\subsection{Usage}

\subsection{Builtin functions}

\section{Obtaining and using the \emph{Nut Shell}}

homepage, usage instructions

\chapter{Table of Terminal Escape Codes}

(...)

\begin{thebibliography}{99}
    \bibitem{}
        Jerry Peek; Tim O'Reilly; Mike Loukides et. al: \emph{Unix Power Tools}. 2nd Edition. O'Reilly \& Associates, Inc, 1997

    \bibitem{}
        dragon book

    \bibitem{}
        wikipedia: backspace

    \bibitem{}
        wp:ansi

    \bibitem{}
        wp:vt100

    \bibitem{}
        EBNF

    \bibitem{}
        tree evaluation

    \bibitem{}
        statistical method

    \bibitem{}
        DSL book
\end{thebibliography}

\end{document}
