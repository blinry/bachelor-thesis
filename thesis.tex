\documentclass[paper=a4,twoside,abstract=on,cleardoublepage=empty,numbers=noenddot,toc=bib,12pt,appendixprefix=true]{scrreprt}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{slantsc}
\usepackage[scaled]{beramono}
\usepackage[ngerman,english]{babel}
\usepackage[style=numeric]{biblatex}
    \addbibresource{bibliography.bib}

\usepackage{xcolor}
    \definecolor{medium-blue}{rgb}{0,0,0.5}

%\setcitestyle{super,square}

\usepackage{blindtext}
\usepackage{multicol}
\usepackage{graphicx}
    \graphicspath{ {images/} }
\usepackage{pgfplots, pgfplotstable}
    \pgfplotsset{compat=1.8}
    \usepgfplotslibrary{statistics}
    \pgfplotsset{
        boxplotcompare style/.style={
            boxplot/draw direction=x,
            % width of boxes:
            boxplot/box extend=0.3,
            % visualize the median as a circle:
            boxplot/draw/median/.code={%
                \draw[fill=white]
                (boxplot cs:\pgfplotsboxplotvalue{median}) circle (3pt)
                ;
            },
        },
        rshift/.style={
            yshift=+\pgfkeysvalueof{/pgfplots/rshift scale},
            legend image post style={yshift=-\pgfkeysvalueof{/pgfplots/rshift scale}},
            solid,
            fill=gray,
            thick,
        },
        lshift/.style={
            yshift=-\pgfkeysvalueof{/pgfplots/lshift scale},
            legend image post style={yshift=\pgfkeysvalueof{/pgfplots/lshift scale}},
            solid,
            fill=white,
            thick,
        },
        rshift scale/.initial=1.2em,
        lshift scale/.initial=1.2em,
    }

\usetikzlibrary{patterns,arrows,fit}
    \makeatletter
    \newcommand\resetstackedplots{
        \makeatletter
        \pgfplots@stacked@isfirstplottrue
        \makeatother
        \addplot [forget plot,draw=none] coordinates{(1,0) (2,0) (3,0) (4,0) (5,0) (6,0) (7,0) (8,0) (9,0) (10,0) (11,0)};
    }
    \makeatother

\usepackage{soul}
    \sethlcolor{darkgray}
    \newcommand{\invert}[1]{\textcolor{white}{\hl{#1}}}
    \newcommand{\cursor}{\invert{ }}
    \newcommand{\escape}[1]{\textasciicircum #1}
\usepackage{hyperref}
    \hypersetup{
        hidelinks
        %colorlinks, linkcolor={medium-blue},
        %citecolor={medium-blue}, urlcolor={medium-blue}
    }
\usepackage[nameinlink]{cleveref}
\usepackage[os=win]{menukeys}
    \renewmenumacro{\keys}[+]{shadowedroundedkeys}
\usepackage{syntax}
%\usepackage{courier}
\usepackage{microtype}
    \DisableLigatures[<,>]{family=tt*}
\usepackage{geometry}
\usepackage{listings}
    \lstdefinelanguage{nutsh}{
        morekeywords={if,else,prompt,def,break,return},
        sensitive=false,
        morecomment=[l]{//},
        morecomment=[s]{/*}{*/},
        morestring=[b]"
    }
    \lstdefinelanguage{commandline}{
        sensitive=false,
        morecomment=[l]{\ \ \ \ },
        morecomment=[l][\bfseries]{\$},
    }
    \lstset{
        aboveskip=10pt,
        belowskip=10pt,
        basicstyle=\ttfamily,
        columns=fullflexible,
        showstringspaces=false,
        literate={`}{\`}1,
    }
    \lstdefinestyle{ebnfstyle}{language=,frame=single}
    \lstdefinestyle{nutshstyle}{language=nutsh,xleftmargin=\parindent}
    \lstnewenvironment{ebnf}{\lstset{style=ebnfstyle}}{}
    \lstnewenvironment{nutsh}{\lstset{style=nutshstyle}}{}

\titlehead{\includegraphics[height=2cm]{tu-logo.pdf} \hfill \includegraphics[height=2cm]{ips.pdf}}

\subject{\normalfont Bachelor Thesis}
\title{The Nut Shell -- A Framework for Creating Interactive Command Line Tutorials}
\author{Sebastian Morr}
\date{2013--11--03}
\publishers{\normalsize%
Institute for Programming and Reactive Systems\\
Prof. Dr. Ursula Goltz\\[\baselineskip]
Advisor: Dr. Werner Struckmann}

\begin{document}

\newgeometry{left=2.5cm,right=2.5cm}
\maketitle
\restoregeometry

\begin{abstract}
    Command line interfaces provide powerful, expressive means to interact with computers, but compared to graphical user interfaces, they have a steep learning curve. Inspired by text adventures, this thesis introduces a new interface concept for teaching command line programs: An interactive, terminal-based tutorial environment, where the documentation reacts to the user's commands, to the command line's response and its internal state.

    The thesis covers design, implementation, application and evaluation of the \emph{Nut~Shell}, a software framework for creating such tutorials.

    An abstraction layer is devised that gives the framework uniform access to the different parts of interaction within arbitrary command line programs, while retaining all their built-in editing features. The framework is compatible with system shells and many interpreted programming languages, but can also be used to teach subtopics, like specific command line tools or concepts.

    The Nut Shell introduces a new domain specific language, that can be used to describe tutorial lessons. The language's syntactic structures are tailored for this purpose and allow for fast and easy content creation. A built-in testing facility enables authors to check their tutorials for proper function automatically.

    In a two-week evaluation study with about 120 participants, a tutorial created with the Nut Shell proved superior to a teaching method based on static text: Users of the Nut Shell showed a much higher motivation to attend to the course, said they had more fun and learned more, and were able to work more autonomously.
\end{abstract}

\selectlanguage{ngerman}%
\begin{abstract}
    Kommandozeilen-Interfaces sind eine mächtige, ausdrucksstarke Art und Weise, mit Computern zu interagieren, sie haben allerdings eine steilere Lernkurve als grafische Inferfaces. Diese Bachelorarbeit stellt ein neuartiges Interfacekonzept zum Lehren von Kommandozeilen-Programmen vor, das durch Textadventures inspiriert ist: Eine interaktive, Terminal-basierte Lernumgebung, deren Anleitungstext auf die Befehle des Benutzers, auf die Antwort der Kommandozeile sowie ihren internen Zustand reagiert.

    Die Arbeit umfasst Design, Implementierung, Anwendung und Evaluierung der \emph{Nut Shell}, einem Softwareframework zum Erstellen solcher Tutorials.

    Eine Abstraktionsschicht wird entworfen, die dem Framework einheitlichen Zugriff auf die verschiedenen Bestandteile der Interaktion innerhalb beliebiger Kommandozeilenproramme erlaubt, wobei deren eingebaute Editierfunktionen benutzbar bleiben. Das Framework ist kompatibel mit System-Shells und vielen interpretierten Programmiersprachen, kann aber auch verwendet werden, um Unterthemen zu lehren, wie etwa spezielle Kommandozeilenwerkzeuge oder -konzepte.

    Für die Nut Shell wurde eine neue domänenspezifische Sprache entwickelt, in der die Tutoriallektionen geschrieben werden können. Die syntaktischen Strukturen der Sprache sind für diesen Zweck maßgeschneidert und machen deshalb das Erstellen von Inhalten schnell und einfach. Eine eingebaute Test-Infrastruktur ermöglicht es Autoren, ihre Tutorials automatisch auf korrekte Funktionsweise zu überprüfen.

    In einer zweiwöchigen Auswertung mit etwa 120 Teilnehmern zeigte ein mit der Nut Shell erstelltes Tutorial klare Vorteile gegenüber einem Lehransatz, der auf statischem Text basierte: Benutzer der Nut Shell waren motivierter, an dem Kurs teilzunehmen, sie hatten mehr Spaß, lernten mehr, und konnten selbstständiger arbeiten.
\end{abstract}
\selectlanguage{english}%

\cleardoublepage

\section*{Acknowledgments}

I would like to thank the following people for their support in the creation of this thesis:
Werner Struckmann patiently answered every question I had.
Hendrik Freytag provided the list of test questions for the evaluation.
Arne Brüsch and Markus Reschke helped making the evaluation a lot of fun and contributed interesting ideas.
Heike Laschin, Moritz Mühlhausen and Leslie Wöhler did some early beta-testing and influenced the style of the final tutorial.
Jan Steiner helped proof-reading the final document.
My family gave me a great amount of support and motivation.
And finally, I want to thank the 120 students who bravely participated in the first evaluation of the Nut Shell and gave helpful and encouraging feedback.

\section*{Colophon}

This document was created using \LaTeXe\ by Leslie Lamport and contributors, and \KOMAScript\ by Frank Neukam, Markus Kohm, and Axel Kielhorn. The figures were created using PGFPlots by Christian Feuersänger and Ti\textit{k}Z by Till Tantau, the key combinations were produced with \emph{menukeys} by Tobias Weh. The text is set in the Latin Modern font family by Bogusław Jackowski, Janusz M. Nowacki and Marcin Woliński, the monospaced font is \texttt{Bera Mono}, based on Bitstream Vera.

\section*{Affidavit}

This thesis is my own unaided work. All sources are acknowledged as references.

\noindent
Ich habe diese Abschlussarbeit selbstständig verfasst. Alle Quellen wurden angegeben.
\\\\
\vskip 5mm
Braunschweig, 2013--11--03
\hskip 1cm \dotfill

\setcounter{tocdepth}{2}
\tableofcontents

\chapter{Introduction}

These days, the most common method for humans to operate computers is via a graphical user interface. It provides buttons and other visual elements the user can interact with using a mouse. Before this interaction method was invented, however, computers had a text-only interface. The user would type a text command, and the machine would execute it. These \emph{command line interfaces} (CLIs) provide powerful, efficient means to interact with computers, which is why many people still can benefit from learning how to use them. But CLIs often have a steep learning curve: Unlike graphical user interfaces, they are not self-evident---users have to know which commands they can enter, which is why novice users definitely need some form of guidance.

Most approaches to teach command line interfaces involve static text: There are books and manuals, online tutorials and exercise sheets. These approaches have several drawbacks: The users have to shift their attention back and forth between the explaining text and the system they want to learn, which slows down the learning process. The text might set tasks and goals, but has no possibility to check and confirm when the user reaches them. Finally, when the user makes a syntactical or semantical mistake, the text remains static and cannot provide any help or correction.

This thesis describes a system that provides a much more direct, interactive teaching approach. The core idea is to interweave the tutorial text and the output of the command line system and to make the tutorial watch the user's commands, in addition to the command line system's state and output, to allow direct response to the user's actions.

This approach is inspired by text adventures. \Cref{fig:zork} shows one of the earliest programs of this kind, \textsc{Zork}, originally released in 1979 by members of the MIT Dynamic Modelling Group \cite{infocom}. In this game, players type short commands of what they want to do, and the game responds with a description of what effects these actions have. Tutorials for technical systems could work similarly: They could provide direct feedback to the users' commands and support them when they make mistakes or encounter problems (note \textsc{Zork}'s response to \texttt{examine mailbox}).

\begin{figure}[tb]
    \begin{lstlisting}[escapechar=@,frame=shadowbox]
West of House
You are standing in an open field west of a white house, with a
boarded front door.
There is a small mailbox here.

> @\textbf{examine mailbox}@
The small mailbox is closed.

> @\textbf{open mailbox}@
Opening the small mailbox reveals a leaflet.

> @\textbf{take leaflet}@
Taken.

> @\textbf{read leaflet}@
"WELCOME TO ZORK!

ZORK is a game of adventure, danger, and low cunning. In it you
will explore some of the most amazing territory ever seen by
mortals. No computer should be without one!"
    \end{lstlisting}
    \centering
    \caption{The beginning of a \textsc{Zork} session.}
    \label{fig:zork}
\end{figure}

Goal of this thesis is to design, implement, apply and evaluate a framework that allows the creation of command line tutorials with this interactive teaching approach. This framework has been called the \emph{Nut Shell}, in reference to the term \emph{in a nutshell} (“to the point”, “short and sweet”).

\section{Prior work}

\emph{Try Ruby} was an interactive online tutorial that would provide an introduction to the Ruby scripting language in the web browser. A notable anonymous programmer called “\_why” first published it at the end of 2005. To the author's knowledge, this was the first attempt to create interactive command line tutorials \cite{why05}. The interface consisted of two sections: One side contained the current task, the other side held an interactive Ruby prompt. The user would then type in commands, and the application would check whether either the command or the interpreter's output matched a regular expression. In this case, the current exercise would be solved and the tutorial would advance to the next one.
The site went offline in early 2009, but some members of the Ruby community continue development.

A web site called \emph{Codecademy}\footnote{\url{http://www.codecademy.com}} deploys several interactive tutorials, which focus on teaching programming in Ruby, Python, JavaScript and PHP. The tutorials consist of multiple exercises, in each of which users get a piece of unfinished code in addition to a task. They are then supposed to fix or complete the code so that it satisfies a number of conditions, which can be quite complex. Every time the code is saved, the conditions are checked. On success, the tutorial advances to the next exercise.

The site \emph{Code School}\footnote{\url{http://www.codeschool.com}} follows a similar approach: It offers courses about Ruby, JavaScript, HTML/CSS, R and Git, which are designed similarly to Codecademy's. The company behind Code School is also responsible for \emph{Try Git}\footnote{\url{http://try.github.io}} and the current \emph{Try Ruby} implementation\footnote{\url{http://tryruby.org}}, which work similarly to the original \emph{Try Ruby}.

Although these implementations of interactive tutorials are dramatic improvements over classical, static tutorials, they still have several problems: The courses are linear---each task has to be solved to get to the next one, which is inflexible and allows no adaptation to the individual user.

Furthermore, they do not offer the level of persistence that normal interaction with the command line has: Every entered line is run separately, the system has no internal state. For example, when the user defines a variable, it is lost when entering the next line, because the interpreter is restarted. \emph{Try Ruby} tries to circumvent this restriction by re-executing each command that was entered so far, which slows down the system's response speed over time.

Although the applications provide some command editing capabilities, it is not possible to use comfort functions like searching the command history or using tab-completion. As these techniques are essential for efficient usage of these interfaces, this is a big drawback.

To present the tutorials in a web browser ensures easy, universal access without any setup at all. However, there is no way to incorporate local files or programs into the tutorials, and the later change away from the online tutorial toward the “real” command line environment will make a dramatic difference to the user.

The Nut Shell addresses all these shortcomings: Tutorials can be highly nonlinear, the command line program's state is persistent during a lesson, all editing facilities are kept available and the tutorial is presented in the same environment where it is commonly used---in the terminal.

\section{Overview and organization}

The chapter's structure follows a bottom-up fashion:

\Cref{sec:preliminaries} introduces and defines some of the framework's central topics and terms: \emph{Command line interfaces}, \emph{Terminals}, and related technologies.

\Cref{sec:cliparser} describes the low-level abstraction layer that communicates with the command line process at the core of each Nut Shell tutorial. It explains and demonstrates techniques for adapting to many different command line interfaces and names the requirements the CLIs need to fulfill.

\Cref{sec:lang} specifies details of the domain specific language \emph{nutsh}, which builds upon the command line abstraction layer to allow simple, fast creation of new Nut Shell tutorials. It describes the language's lexical elements, its syntax and semantics and explains how the language is interpreted and tested.

\Cref{sec:evaluation} describes application and evaluation of the Nut Shell in a study that compared the new teaching approach with tutorials based on static text, and tried to find out whether the former offered any benefits.

\Cref{sec:conclusions} provides an outlook and suggests ideas for future work.

%\Cref{sec:implementation} provides an overview of the Nut Shell's implementation and describes usage and installation.

\Cref{sec:nutshexample}, starting on \cpageref{sec:nutshexample}, shows an example session of a tutorial created for the evaluation, followed by its \emph{nutsh} source code. To get an impression of the interaction style employed by the Nut Shell, it may be beneficial to look at this example before continuing to read.

\section{Notation}
\label{sec:ebnf}

In this thesis, grammars are specified using the \emph{Extended Backus-Naur Form} (EBNF) as used in \cite{wirth77}. As a convention, capitalized names represent nonterminal symbols, whereas lowercase names represent terminal symbols. Unless mentioned otherwise, the name of a grammar's first production is its starting symbol.

Vertical bars (\texttt{|}) separate alternatives, square brackets (\texttt{[ ]}) denote optional parts and curly brackets (\texttt{\{ \}}) denote an arbitrary number of repetitions. Tokens are enclosed in double quotes or back quotes.

Grammars are displayed in the following style---this is also a specification of the EBNF flavour as used in this thesis, given in EBNF itself:

\begin{ebnf}
Grammar     = { Production } .
Production  = production_name "=" [ Expression ] "." .
Expression  = Alternative { "|" Alternative } .
Alternative = Term { Term } .
Term        = production_name | token | Group | Option | Repetition .
Group       = "(" Expression ")" .
Option      = "[" Expression "]" .
Repetition  = "{" Expression "}" .
\end{ebnf}

\chapter{Preliminaries}
\label{sec:preliminaries}

\section{Command line interfaces}
\label{sec:cli}

A \emph{command line interface} (\textsc{CLI}) allows a user to communicate with a computer program by entering lines of text, the \emph{command lines}.
%This thesis focuses on purely character-based command line interfaces that have no graphical capabilities.

Commonly, interaction with a \textsc{CLI} consists of three phases:

\begin{enumerate}
    \item The program writes a \emph{prompt}, a special character sequence that signals to the user that the program now expects a command.
    \item The user composes a command line. Often, the CLI offers several editing capabilities that make this process more comfortable, like a command history or completion of nonambiguous terms when pressing \keys{Tab}. To tell the program to execute the command, the user usually sends a \emph{line feed} character by pressing the \keys{Return} key.
    \item The program interprets and executes the command, and displays a response. Sometimes, the execution is \emph{interactive} and requires further input. After the command has finished, the first phase starts again.
\end{enumerate}

In this thesis, the examples will use IRB, the \emph{Interactive Ruby Shell}. Ruby is an object-oriented scripting language, and, at the basic level, can be used to evaluate arithmetic expressions. \Cref{fig:irb} shows a few iterations of the three phases mentioned earlier: The characters \texttt{>\->} constitute the prompt; the following characters, set in a bold typeface, are the commands the user typed; and the subsequent lines are the program's output.

\begin{figure}[tb]
    \begin{lstlisting}[escapechar=@,frame=shadowbox]
>> @\textbf{2**16}@
=> 65536
>> @\textbf{Math.sqrt(2)}@
=> 1.4142135623730951
>> @\textbf{6*7 == 42}@
=> true
    \end{lstlisting}
    \centering
    \caption{An example IRB session.}
    \label{fig:irb}
\end{figure}

\label{sec:cliexamples}

Another very common command line program is \emph{Bash}, the default system shell on Linux and Mac OS X, which can be used to manipulate the file system. It supports some convenient functions like tab-completion of filenames or advanced access to the command history and offers many syntactic structures for manipulating streams of text.

Further examples of command line programs include interpreters of the programming languages Python, Haskell or Perl, SQL consoles or mathematics software like gnuplot or Sage.

\section{Terminal}

In the past, a \emph{computer terminal} was a device for communication with mainframe computers. They read text from the user via a keyboard and displayed the computer's output, first on paper, later on a screen.

Here, when we use the term \emph{terminal}, we mean a modern \emph{terminal emulator}, a program that resembles a computer terminal within an otherwise graphical environment. Inside these terminal emulators, command line programs can be run.

Terminals communicate through sequential streams of characters: They receive characters from the user's keyboard, send them to the program running inside, and they receive characters back from the program to be displayed on the screen.

\section{Escape sequences and control characters}

Not only are terminals able to output text, they also provide methods to influence its appearance and format.

Nowadays, modern terminal emulators mimic the behaviour of the classical computer terminal \textsc{VT100}, introduced in 1978 by \textsc{Digital Equipment Corporation} \cite{upt02}. This device had the following mechanism for influencing the output: When given special character sequences to display, the terminal performed predefined actions like moving the cursor, deleting characters on the screen or turning graphical modes (underlining, colors) on or off. Because these sequences “escape” their normal path of being displayed as text, they are called \emph{escape sequences}, and in this context indeed start with an \emph{escape} character. The \textsc{VT100} was not the first terminal to handle those sequences, but its popularity caused widespread support for its set of escape sequences, that were later specified in \textsc{ISO}/\textsc{IEC} 6429 \cite{iso6429}.

Additionally, the \textsc{ASCII} characters below 32, the \emph{control characters}, have special meanings in terminals.
%\Cref{sec:esc} lists the control characters and the escape sequences which are still common today.
To denote control characters, which would be invisible otherwise, \emph{caret notation} is commonly used: To represent the \textsc{ASCII} character of the value $n$, a caret symbol (\texttt{\textasciicircum}) is combined with the \textsc{ASCII} character with the value $n+64$. For example, the \emph{backspace} character has the \textsc{ASCII} value $8$; the \textsc{ASCII} character with the value $72$ is \texttt{H}, so the caret notation for a \emph{backspace} is \texttt{\escape{H}}. This notation originates from the fact that in old terminals, the control characters could be entered by pressing \keys{\ctrl} and the respective letter key. For some characters this is still true today: For example, \keys{\ctrl+D} produces \emph{end of file}, \keys{\ctrl+H} produces \emph{backspace}, and \keys{\ctrl+J} produces a \emph{line feed} character.

\section{Readline}

To make text input more comfortable, many CLIs offer a wide range of editing capabilities. They support key combinations for deleting characters, words or whole lines, and often maintain a history of entered commands, so that the user can access them later if necessary.

To avoid having to implement these features themselves, many command line programs use a library called \textsl{\textsc{GNU} Readline} \cite{readline}. This library has some default keybindings for deleting parts of the current command and moving the cursor, which originate from the Emacs text editor. Even if a program does not use Readline directly, many of its bindings have become a de-facto standard for command line editing and thus can be expected to work in a command line environment.

\chapter{The \textsc{CLI} Abstraction Layer}
\label{sec:cliparser}

The \textsl{\textsc{CLI} abstraction layer} is the framework's lowest-level component, which wraps around the command line process that is to be taught. It has the goal of recognizing the different parts of the command line interaction, creating a layer of abstraction that enables the framework to treat all supported \textsc{CLI}s identically. The interesting parts in this context are the following three, which correspond to the phases described in \cref{sec:cli}:

\begin{enumerate}
    \item Which prompt is displayed to the user?
    \item Which command does the user enter?
    \item What is the output of this command?
\end{enumerate}

The abstraction layer is needed for two further reasons: First, the Nut Shell needs to check conditions on the user's commands or the output. Second, it allows the Nut Shell to run commands itself, hidden to the user, while having access to the same state of the command line system. The sophisticated methods described in this chapter are necessary to keep all editing features intact, including tab completion and usage of the command line history.

This thesis treats the targeted command line process as a black box having input and output streams of Unicode characters. The \textsc{CLI} abstraction layer watches and modifies these streams as described in the following sections.

The main idea here is to use two special \emph{markers}, unique character sequences that are unlikely to appear in normal command line interaction, to annotate the output of the process. A suitable choice for those markers are Unicode code points from the \emph{Private Use Area}, which are guaranteed not to be assigned any meaning \cite[p. 558]{unicode6.2}, for example \texttt{U+E100} and \texttt{U+E101}. We call these \emph{marker1} and \emph{marker2}.

\section{Targets}
\label{sec:targets}

The Nut Shell is designed to support as many different command line interfaces as possible; examples of command line programs can be found in \cref{sec:cliexamples}. When we talk about one of these programs, we call it the Nut Shell's current \emph{target}.

As these programs can have different internal implementations, the abstraction layer has to rely on common features, that can be found in all of them. As described in the preliminaries, fortunately many \textsc{CLI}s used today follow the same conventions.

For the abstraction layer to work, a command line program needs to have two features:

\begin{enumerate}
    \item User customizable prompts.
    \item Readline-style keybindings. Mandatory are these three key combinations:
        \begin{itemize}
            \item \keys{\ctrl+E} has to jump to the end of the line.
            \item \keys{\ctrl+U} has to delete the momentarily entered line and puts it in an internal buffer.
            \item \keys{\ctrl+Y} has to reinsert the content of this buffer.
        \end{itemize}
\end{enumerate}

All command line programs mentioned in \cref{sec:cliexamples} have those features and thus can be used as \emph{targets}.

\section{High-level architecture}

\Cref{fig:architecture} depicts the architecture of the abstraction layer. The command line process at the bottom has input and output streams of Unicode characters. The output is read by the \emph{Tokenizer}, which splits it into tokens of the types “prompt”, “command”, or “output”. In addition to that, the \emph{Tokenizer} sends characters to the \emph{Logic} component that originate from interactive programs and need to be displayed before the token is complete. The logic component can then check conditions on the tokens and send appropriate text to the terminal.

\begin{figure}[htb]
    \begin{tikzpicture}[nodes={rectangle,draw},->,>=stealth',thick,align=center,inner sep=0]
        \node[fit={(-3,-0.5) (3,0)},label=center:CLI process] (process) {};
        \node[fit={(-3,1.5) (-0.5,2)},label=center:Input filter] (filter) {};
        \node[fit={(3,1.5) (0.5,2)},label=center:Tokenizer] (tokenizer) {};
        \node[fit={(3,3.5) (-1.5,4)},label=center:Logic] (logic) {};
        \node[fit={(-3,5.5) (3,6)},label=center:Terminal] (terminal) {};
        \node[fit={(-3,7.5) (-0.5,8)},label=center:Keyboard] (keyboard) {};
        \node[fit={(3,7.5) (0.5,8)},label=center:Screen] (screen) {};

        \draw[dashed] (-1.75,7.5) -- (-1.75,6);
        \draw[dashed] (-2.375,5.5) -- (-2.375,2);
        \draw[dashed] (-1.75,1.5) -- (-1.75,0);

        \draw[dashed] (-1.125,3.5) -- (-1.125,2);

        \draw[dashed] (1.75,0) -- (1.75,1.5);

        \draw[dashed] (1.125,2) -- node[draw=none,left,inner sep=5pt]{tokens} (1.125,3.5);
        \draw[dashed] (2.375,2) -- (2.375,3.5);

        \draw[dashed] (1.75,4) -- (1.75,5.5);
        \draw[dashed] (1.75,6) -- (1.75,7.5);
    \end{tikzpicture}
    \centering
    \caption{Information flow between the Nut Shell's components. Unlabeled streams carry Unicode characters.}
    \label{fig:architecture}
\end{figure}

On the input side, the user's input, originating from the \emph{Terminal}, is modified by the \emph{Input filter} in the manner described in the upcoming \cref{sec:reccmd}. The result is then given to the process as standard input. The \emph{Input filter} processes commands given by the \emph{Logic} component in the same way. This channel is used for commands that check conditions in the process.

The \textsc{EBNF} grammar shown in the following sections describe how the tokenizer processes the output of the command line to split it into tokens.

At a high-level view, the output of the process as a whole consists of three segments:
The first segment is the prompt, enclosed in markers, as explained in the following section.
The second segment contains characters entered by the user while composing the command; the segment may include escape sequences and control characters, which are produced while performing editing operations.
The final segment contains the command's output, that simply consists of nonmarker characters.
This sequence of segments can repeat indefinitely:

\begin{ebnf}
Output = { PromptWithMarkers CommandComposing CommandOutput } .
CommandOutput = { NonMarker } .
NonMarker = /* every character except marker1 and marker2 */ .
\end{ebnf}

\section{Recognizing the prompt}

The prompt is the easiest component to recognize. As the prompt of the target process can be changed (by definition, see \cref{sec:targets}), the Nut Shell configures the prompt to start and end with \emph{marker1}. Looking at the output, the prompt can now be identified nonambiguously. The markers are skipped and are not displayed to the user.

In this part of the grammar, the token we are really interested in is \texttt{Prompt}:

\begin{ebnf}
PromptWithMarkers = marker1 Prompt marker1 .
Prompt = { NonMarker } .
\end{ebnf}
%
This approach has a downside: In some command line programs it is possible to change the prompt from \emph{within} the program. If the user tries to change the prompt himself, the tokenizer will probably break.

To add support for a new command line program to the Nut Shell, one has to create a profile that specifies which options and commands are necessary to configure the prompt so it begins and ends with markers.

\section{Recognizing the command}
\label{sec:reccmd}

When the user enters characters with the keyboard, normally, these characters are immediately displayed on the screen. This means that in the phase of entering a command, the input of the underlying process is equal to its output.

Unfortunately, this is only true for visible characters. While editing the command line, a user may use Readline's key bindings or other shell built-in key combinations that modify the currently entered command in unusual ways. These make it hard for the framework to recognize which command the user entered, as parts of the entered characters could have been deleted, otherwise have been changed, or---even worse---have been generated by the program and never have been entered by the user, as it happens with \emph{tab completion}. To solve this problem, the \emph{Input filter} component deploys a mechanism to repeat the entered line before it is sent.

When the user is done editing the command, wants to run it and produces a \emph{line feed} character by pressing \keys{Return}, the Nut Shell does not send this character to the process. Instead, it proceeds in the following way:

\begin{enumerate}
    \item The cursor is positioned at the end of the line using \keys{\ctrl+E}. This is necessary as the user could have positioned the cursor somewhere inside the command.
    \item A \emph{space} character is inserted. This prevents problems when the command was completely empty before, as the following step would not do anything in this case.
    \item The whole line is deleted and put into an internal buffer using \mbox{\keys{\ctrl+U}}.
    \item A \emph{marker1} is inserted and immediately deleted afterward, so it does not end up in the command later.
    \item The deleted command is reinserted using \keys{\ctrl+Y}.
    \item Another \emph{marker1} is inserted and deleted.
    \item The \emph{space} character that was inserted in step 2 is deleted.
    \item Finally, a \emph{line feed} character is written to the process to start execution of the command.
\end{enumerate}

To summarize, this is the whole sequence as it is sent to the process:

\begin{quote}
    \keys{\ctrl+E} \keys{space} \keys{\ctrl+U} \emph{marker1} \keys{backspace} \keys{\ctrl+Y} \emph{marker1} \keys{backspace} \keys{backspace} \keys{\return}
\end{quote}

Because \keys{\ctrl+Y} repeats the whole command as the user intended to run it, it now appears in the output neatly framed by the two markers. The screen's content, however, looks the same to the user.

\begin{table}[tb]
    \centering
    \caption{Example of the command marker technique.}
    \label{tab:cmdmarking}
    \begin{tabular}{r|l|l|l|l}
        & Keystrokes & Input & Output & Screen content \\
        \hline
        1 & & & \texttt{>>␣} & \texttt{>>␣\cursor} \\
        2 & \keys{1} \keys{-} \keys{1} & \texttt{1-1} & \texttt{1-1} & \texttt{>>␣1-1\cursor} \\
        3 & \keys{\arrowkeyleft} & \texttt{\escape{[}[D} & \texttt{\escape{H}} & \texttt{>>␣1-\invert{1}} \\
        4 & \keys{backspace} & \texttt{\escape{H}} & \texttt{\escape{H}} & \texttt{>>␣1\invert{-}1} \\
        5 & & & \texttt{\escape{[}[1P} & \texttt{>>␣1\invert{1}} \\
        6 & \keys{{+}} & \texttt{+} & \texttt{+} & \texttt{>>␣1+\cursor} \\
        7 & & & \texttt{1} & \texttt{>>␣1+1\cursor} \\
        8 & & & \texttt{\escape{H}} & \texttt{>>␣1+\invert{1}} \\
        9 & \keys{\return} & \texttt{\escape{E}} & \texttt{\escape{[}[C} & \texttt{>>␣1+1\invert{ }} \\
        10 & & \texttt{␣} & \texttt{␣} & \texttt{>>␣1+1␣\invert{ }} \\
        11 & & \texttt{\escape{U}} & \texttt{\escape{H}\escape{H}\escape{H}\escape{H}} & \texttt{>>␣\invert{1}+1␣} \\
        12 & & & \texttt{\escape{[}[K} & \texttt{>>␣\invert{ }} \\
        13 & & \emph{marker1} & \emph{marker1} & \texttt{>>␣}\emph{marker1}\texttt{\invert{ }} \\
        14 & & \texttt{\escape{H}} & \texttt{\escape{H}\escape{[}[K} & \texttt{>>␣\invert{ }} \\
        15 & & \texttt{\escape{Y}} & \texttt{1+1␣} & \texttt{>>␣1+1␣\invert{ }} \\
        16 & & \emph{marker1}\texttt{\escape{H}} & \emph{marker1}\texttt{\escape{H}\escape{[}[K} & \texttt{>>␣1+1␣\invert{ }} \\
        17 & & \texttt{\escape{H}} & \texttt{\escape{H}\escape{[}[K} & \texttt{>>␣1+1\invert{ }} \\
    \end{tabular}
\end{table}

\Cref{tab:cmdmarking} demonstrates the technique in a prototypic example. The first column lists the user's keystrokes, the second one contains the characters sent to the process, the third one contains the output of the process, and the final one shows the current content of the screen. The gray rectangle indicates the cursor position. In the example, the program first writes a prompt. The user enters \texttt{1-1}, and then replaces the \texttt{-} character with a \texttt{+} using arrow keys and \emph{backspace}. The first three characters are routed from the program's input to its output literally. In line 3, the left arrow key sends the escape sequence \texttt{\escape{[}[D} to the program, which means “move the cursor backward”. In the output, this is transformed to \texttt{\escape{H}}, a \emph{backspace} character, which has the same effect in the terminal. In line 4, the \emph{backspace} character in the input is translated into \texttt{\escape{H}} (move the cursor backwards) and \texttt{\escape{[}[1P} (delete one character) in the output. The minus sign is now no longer displayed on the screen. In line 6, the insertion of the \texttt{+} character has the following effect: The \texttt{+} and the text after the cursor (a \texttt{1}) is rewritten, and the cursor is then moved back to its position inside the command using \texttt{\escape{H}}.

From the content of the “Output” column up to line 9, it is hard to recognize the actual command \texttt{1+1} (which is displayed on the screen) because of the inserted escape sequences and control characters. When the user presses \emph{return}, it is not forwarded, but the previously described sequence is sent to the process instead. In line 9, the cursor is moved to the end of the line using \texttt{\escape{[}[C} (move the cursor forward). In line 11, the command is deleted by moving the cursor to the beginning of the line with \texttt{\escape{H}} and clearing the terminal's current line from the cursor to the right with \texttt{\escape{[}[K}. After that, no new escape sequences appear: The marker is inserted and deleted, the command is repeated, another marker is inserted and deleted, and finally the space character is removed.

When reading the “Output” column, the correct command \texttt{1+1} now appears neatly between the two markers. The first marker is followed by a deletion sequence, and the command is always followed by a space character. By removing both, the exact command the user wanted to enter can be extracted.

To summarize, for the tokenizer, the composing sequence has two phases: In the first one, the actual command line composing takes place. In the second one, the current line is deleted and reprinted as described earlier. The interesting part here is \texttt{Command}:

\begin{ebnf}
ComposeAndRepeat = LineComposing LineRepetition .
LineComposing = { NonMarker } .
LineRepetition = space Deletition Marker Deletion Command
    Marker Deletion "\r" .
Deletition = { deletition_sequence } .
Command = { NonMarker } .
\end{ebnf}

\subsection*{Multi-line commands}

Before execution, some \textsc{CLI}s check whether an entered command is somehow incomplete: It could, for example, lack a closing parenthesis, or end with an operator. In this case, the program does not execute the command, but gives the user the possibility to finish it. For this purpose, the \textsc{CLI} usually displays a prompt which is different to the primary prompt, so that the user can tell the difference. The framework inserts the second marker into this secondary prompt, so that it can be appropriately recognized, as well.

After the previously described line repetition, the tokenizer looks at the next character---if it is a secondary-prompt-marker, it knows another composing-and-repeating step will follow, as the user will now type a second line:

\begin{ebnf}
SecondaryPromptWithMarkers = marker2 Prompt marker2 .
CommandComposing = ComposingAndEcho
    [ { SecondaryPromptWithMarkers ComposingAndEcho } ] .
\end{ebnf}
%
When no secondary prompt follows, all previous occurrences of the \texttt{Command} token are appended to get the full command.

\section{Command line operations}
\label{sec:cliops}

Using the described techniques, the abstraction layer is able to tokenize the program's output. It sends the resulting tokens to the program logic, which can then perform two important operations:

The logic can prompt the user for a command. The first \texttt{Prompt} token that is received is written to the terminal. The recomposed \texttt{Command} tokens are stored as the user's command, and the following \texttt{Output} token is stored as the command's output. The characters which make up the command line's output are also sent to the logic through the second channel (see \cref{fig:architecture}). These characters are displayed on the terminal, so the user can see what he is typing and can use interactive programs that require him to enter further text before the command's execution terminates.

The second important operation is to send a command to the \textsc{CLI} to check a condition or to change the program's internal state. To do this, the command is sent directly to the \emph{Input Filter}. The command and output tokens are captured as before, but their content is not displayed to the user.

\chapter{The \emph{nutsh} Language}
\label{sec:lang}

To enable authors to write tutorials for the Nut Shell quickly, the framework includes a new imperative \emph{domain-specific programming language} (\textsc{DSL}). This language is called \emph{nutsh}, a contraction of “Nut Shell”. Files written in the \emph{nutsh} language represent “lessons”, self-contained teaching units.

\section{Design goals}

The lesson's source code should be as easy to read and write as possible. To achieve this, \emph{nutsh} uses a syntax that in large parts resembles languages that potential users already may know. In this case, it resembles the syntax of C, with some influences of Google Go \cite{google13}, for example in the definition of string literals and the syntax of conditional clauses. It also uses regular expressions and a few elements of the markup language \emph{Markdown}.

Another design goal was to keep the language as small as possible, while making it powerful enough for the intended purpose. For this reason, its only data type is a string of Unicode characters. Variables also proved unnecessary.

The language contains syntactic structures that allow efficient expression of often-used semantical constellations. It also allows basic function definitions to reuse code snippets and minimize redundancy.

The following sections specify the language's lexical and syntactical elements and describe their semantics.

\section{Lexical elements}

\minisec{Comments}

\emph{nutsh} has two types of comments, as they exist in C-like languages: \emph{Line comments} start with \texttt{//} and stop at the end of the line, \emph{block comments} start with \texttt{/*} and end with \texttt{*/}. Comments act as white space and are ignored otherwise.

\minisec{White space}

Whites space consists of line feeds, carriage returns, tab and space characters. It separates tokens but has no further meaning.

\minisec{Identifiers}

Identifiers serve as names that can be used for functions. An identifier is a nonempty sequence of alphanumeric characters.

\begin{ebnf}
Identifier = alnum_char { alnum_char } .
\end{ebnf}

\minisec{Keywords}

\emph{nutsh} uses the following keywords, which must not be used as identifiers:

\begin{quote}
    \texttt{break}\hspace{0.5em}
    \texttt{def}\hspace{0.5em}
    \texttt{else}\hspace{0.5em}
    \texttt{if}\hspace{0.5em}
    \texttt{prompt}\hspace{0.5em}
    \texttt{return}
\end{quote}

\minisec{Operators and delimiters}

The following character sequences have special meanings in \emph{nutsh}:

\begin{quote}
    \texttt{=\textasciitilde}\hspace{1em}
    \texttt{==}\hspace{1em}
    \texttt{||}\hspace{1em}
    \texttt{,}\hspace{1em}
    \texttt{!}\hspace{1em}
    \texttt{(}\hspace{1em}
    \texttt{)}\hspace{1em}
    \texttt{\{}\hspace{1em}
    \texttt{+}\hspace{1em}
    \texttt{\}}\hspace{1em}
    \texttt{\&\&}
\end{quote}

\minisec{String Literals}

There are two types of string literals: \emph{raw string literals} and \emph{interpreted string literals}. Raw string literals are enclosed in back quotes (\texttt{\`}). They may contain any character except the back quote; other characters are interpreted literally. Interpreted string literals are enclosed in double quotes (\texttt{"}) and may contain backslash escaped characters, like \texttt{\textbackslash{}n} for a newline or \texttt{\textbackslash{}"} for a double quote, and byte values in hexadecimal (\texttt{\textbackslash{}x??}) or octal form (\texttt{\textbackslash{}???}).\footnote{Due to the implementation, \emph{nutsh} accepts strings of the same format as Go. The full specification can be found at \cite{google13}.}

\begin{ebnf}
string = raw_string | interpreted_string .
raw_string = "`" { unicode_char } "`" .
interpreted_string = `"` { unicode_char | escaped_char |
    byte_value } `"` .
\end{ebnf}

\section{Syntax and semantics}

\subsection{Expressions}

\minisec{String Expressions}

The \emph{nutsh} language makes strong use of strings (\texttt{"foo"}). String expressions can be concatenated (\texttt{"foo"+"foo"} has the same value as \texttt{"foofoo"}) and be checked for equality (\texttt{"foo" == "foo"}). Additionally, it can be checked whether a string matches a regular expression (\texttt{"foo" =\textasciitilde\ "f[aio]."}).\footnote{Using the syntax of the regular expression parsing library \emph{RE2} as described here: \url{http://code.google.com/p/re2/wiki/Syntax}} Every string can be interpreted as a truth value, which is \emph{false} for an empty string and \emph{true} otherwise. The common boolean operators (\texttt{!} for \emph{not}, \texttt{\&\&} for \emph{and}, and \texttt{||} for \emph{or}) are defined accordingly. They return the (arbitrary) nonempty string \texttt{"true"} as a truth value.

\begin{ebnf}
StringExpression =
    string | Call | StringExpression Operator StringExpression |
    "!" StringExpression | "(" StringExpression ")" .

Operator = "+" | "==" | "=~" | "&&" | "||" .
\end{ebnf}

\minisec{Operator precedence}

String concatenation binds strongest, followed by the two comparison operators, logical \emph{not}, logical \emph{and}, and finally logical \emph{or}. Operators bind from left to right: \texttt{a~OP b OP c} has the same meaning as \texttt{(a OP b) OP c}.

\minisec{Calls}

\emph{nutsh} knows \emph{functions}, which can be called by specifying the correct number of arguments. If a function takes no arguments, the brackets can be omitted. As a special case, a string on its own also acts as a function call, see the following section.

\begin{ebnf}
Call = identifier [ "(" [ StringExpressions ] ")" ] | string .
StringExpressions = StringExpression { "," StringExpression } .
\end{ebnf}

\subsection{Built-in functions}

A central command in \emph{nutsh} is the output of explanation text. This text will be displayed indented and highlighted in a different color.

\begin{nutsh}
say("This is explaining text.")
\end{nutsh}
%
Because this command is used so often, it can be abbreviated to:

\begin{nutsh}
"This is the short form."
\end{nutsh}
%
The \texttt{say} function supports two ways of highlighting parts of the text: Text enclosed in back quotes will be displayed in a second color, text enclosed in asterisks in a third. As a convention, back quotes are used to mark parts of commands or file names, and asterisks are used to emphazise parts of a sentence. These conventions have been adopted from John Gruber's Markdown.\footnote{\url{http://daringfireball.net/projects/markdown/syntax}}

The \texttt{run} function executes a command in the target process, it takes a command line \emph{in the target language} as an argument. The return value of this function is the command's output. The function can be used to check for conditions in the command line environment.

\begin{nutsh}
run("1+1")
\end{nutsh}

\subsection{Statements}
\label{sec:statements}

\minisec{Blocks}

A \emph{block} is a sequence of lines:

\begin{ebnf}
Block = "{" { Line } "}" .
Line = IfStatement | PromptStatement | NestingStatement | Call .
\end{ebnf}

\minisec{If statements}

If the conditional expression of an \texttt{if} statement evaluates to \emph{true}, the first block is evaluated, otherwise the (optional) second block. There are no brackets around the condition.

\begin{ebnf}
IfStatement = "if" StringExpression Block ( "else" Block ) .
\end{ebnf}
%
This example checks a string for equality with itself and prints an according message:

\begin{nutsh}
if "test" == "test" {
    "Everything is OK."
} else {
    "Wait, what?"
}
\end{nutsh}

\minisec{Prompt statements}

The prompt statement is another central element of \emph{nutsh}'s syntax. It has the semantic of an endless loop, in which a command is read from the user at the beginning of each pass. This way, it can be used to represent a state in the tutorial, in which the user can execute commands. The prompt loop can be left with a \texttt{break} statement.

\begin{ebnf}
PromptStatement = "prompt" Block .
\end{ebnf}
%
There are two built-in functions called \texttt{command} and \texttt{output}, that correspond to the user's latest command and its output. When no prompt has occurred yet, they return empty strings.

In this example, the user is asked to enter a command that has the output “42”. When he obeys, the prompt loop is left with a \texttt{break} statement, otherwise he has to try again:

\begin{nutsh}
"Please calculate the product of 6 and 7."

prompt {
    if output == "42" {
        break
    } else {
        "Please try again."
    }
}

"Well done!"
\end{nutsh}

\minisec{Function definitions}

To define a new function, the \texttt{def} keyword is used, followed by the name of the function, optional arguments and a block. If a function has no arguments, the brackets around the arguments can be omitted:

\begin{ebnf}
Definition = "def" identifier [ Arguments ] Block .
Arguments = "(" [ identifier { "," identifier } ] ")" .
\end{ebnf}
%
As an example, we define a function that prints its argument twice, and call it:

\begin{nutsh}
def say_twice(text) {
    say(text)
    say(text)
}

say_twice("Hey!")
\end{nutsh}

\minisec{Nesting statements}

Sometimes, the same set of conditions needs to be checked for a group of prompt statements. In this case, nesting statements can be used. They consist of one or more function calls, followed by a block.

\begin{ebnf}
NestingStatement = Calls Block .
Calls = Call { "," Call } .
\end{ebnf}
%
Inside a nesting statement, the specified calls are executed each time after the user has entered a command. There can be more than one level of nesting---the outmost nested functions are called first.

In this example, a function is defined that prints a message when the user enters a command that contains “help”. For two \texttt{prompt} statements, a nesting statement is defined to call this function. Now, every time the user enters a command in these two prompt loops, the function is called. For another example of this syntax, refer to the implementation of the example lesson in \cref{sec:nutshexample}, starting on \cpageref{lst:compress}.

\begin{nutsh}
def respond_to_help {
    if command =~ "help" {
        "Sorry, you're on your own."
    }
}

respond_to_help {
    prompt {
        // break condition ...
    }
    prompt {
        // break condition ...
    }
}
\end{nutsh}

\subsection{Top level structure}

A \emph{nutsh} file consists of several function definitions and other \texttt{Line} instances (\texttt{if}-, \texttt{prompt}- and nesting statements in addition to calls, see \cref{sec:statements}). Thus, function definitions can only appear at the top level to avoid redefinitions in different scopes, which would lead to name masking problems and a much higher complexity. \texttt{Lesson} is the start symbol of \emph{nutsh}'s grammar:

\begin{ebnf}
Lesson = { Definition | Line } .
\end{ebnf}

\section{Parsing and interpretation}

\emph{nutsh} has a $LR(1)$ grammar, which means that it can be parsed by a bottom-up parser reading from left to right in a single pass, creating a rightmost derivation. For parsing, \emph{nutsh} uses a standard $LALR(1)$ parser generator, more details can be found in \cref{sec:implementation}.
The parser creates a \emph{syntax tree} whose nodes have a string value and an arbitrary number of child nodes. For leaf nodes, the string value represents the lexical value, for inner nodes, it represents the node's type.

When a function definition is encountered, the definition node along with its children is added to the symbol table. After it has been defined, the function can be called until the end of the source file. As functions can only be defined at the top level, no dedicated scoping is necessary.

When evaluating a string expression, a node's value can be calculated from its children's values, the attribute is \emph{synthesized}. This makes an evaluation of the syntax tree especially easy, as the interpreter can now travel through the tree in a bottom-up manner. \emph{nutsh} uses \emph{lazy evaluation}: An expression is only evaluated when it is needed.

The arguments to a function, however, are always evaluated, the resulting value is bound to the corresponding argument name in the function (\emph{pass-by-value}), implicitly defining new functions for each argument, which simply return the argument's value.

While traversing the syntax tree, the interpreter keeps track of the encountered nesting statement's function calls, which are pushed on a stack when entering the nesting statement and which are removed when leaving it. When a \texttt{prompt} node is encountered, the \emph{CLI abstraction layer} is used to prompt the user for a command. The command and its output are saved so they can be accessed when the \texttt{input} and \texttt{output} functions are called. After that, the calls in the nesting stack are executed from bottom to top. Finally, the block inside the \texttt{prompt} statement is evaluated.

\section{Automated testing}
\label{sec:testing}

As a tutorial author, one wants to verify that all lessons work correctly. The framework provides a facility for automated testing, so the author does not have to enter all required commands by hand to test his tutorial.

The framework provides the built-in function \texttt{expect}, which expresses the assumption of the lesson's author that if a user were to enter the supplied argument as a command in the innermost surrounding \texttt{prompt} statement, the \texttt{expect} statement would be reached.

In this example, the string variable \texttt{text} is defined. The user is then asked to reverse it. The \texttt{expect} statements give two different ways to achieve that---both should work. There's also an \texttt{expect} statement that should \emph{not} lead to an evaluation of the first block:

\begin{nutsh}
run("text = 'stressed'")
"Reverse the content of `text` and save it in `text2`!"
prompt {
    if test("text2 == 'desserts'") {
        "You did it!"
        expect("text2 = text.reverse")
        expect("text.reverse!; text2 = text")
        break
    } else {
        expect("text2 = 'somethingdifferent'")
    }
}
\end{nutsh}

The testing algorithm first collects all \texttt{expect} statements and creates a reference for each of them in the nearest surrounding \texttt{prompt} statement. Each is marked as “unreached”.

It then starts interpreting the file like normally, but when a \texttt{prompt} statement is encountered, instead of querying the user for a command, one of the unreached associated \texttt{expect} commands is used. When the respective \texttt{expect} statement indeed is reached, the statement is marked as “reached”. When the end of the prompt loop is encountered, and the \texttt{expect} has not been reached, an error is printed and the test is aborted. At the end of the file, if there are any unreached \texttt{expect} statements left, the lesson is restarted.

By convention, when a prompt is encountered whose \texttt{expect} statements all are reached, the first one is used. Thus, the first \texttt{expect} in each prompt should be one that leads to a \texttt{break} statement to ensure the testing algorithm terminates. A more flexible approach would be to create a \emph{control flow graph} for the lesson and ensure that every branch is considered while testing by choosing \texttt{expect} statements that lead to not yet tested parts of the lesson.

\chapter{Implementation}
\label{sec:implementation}

The framework has been implemented in \emph{Go} \cite{google13}, a young, compiled, statically typed language, which is seen by many as a modern successor to C. This language was a good fit for the Nut Shell as it is fast, was created with low-level programming in mind, and has a big standard library with built-in support for Unicode and UTF-8. In total, the implementation consists of 2576 source lines of code.

The implementation uses folders to represent tutorials, which can contain several lesson files written in the \emph{nutsh} language. A configuration file named \texttt{info.yaml} specifies the tutorial's name and the target command line program that is to be used. A file called \texttt{common.nutsh} can be used to define functions that are included in every lesson.

The source code is organized in four subpackages: The \texttt{cli} package implements the command line abstraction layer as described in \cref{sec:cliparser}. It uses the \texttt{pty} package\footnote{\url{http://github.com/kr/pty}} to emulate a terminal, and starts a thread for each component in \cref{fig:architecture}. Go's built-in support for concurrency and synchronized communication between threads came in handy here.

The \texttt{dsl} package uses the abstraction layer to provide an internal API that allows easy access to important operations, like starting and destroying command line processes, prompting the user for a command or sending a hidden query to the command line, as described in \cref{sec:cliops}.

The \texttt{model} package understands the directory structure described earlier, and provides operations like initializing a tutorial, presenting a list of lessons to the user to choose from, or saving the current progress. The progress simply consists of a list of finished lessons, so they can be displayed as “done”. The \texttt{goyaml} package\footnote{\url{http://launchpad.net/goyaml}} was used to read and write configuration files written in the \textsc{YAML} markup language.

Finally, the \texttt{parser} package is responsible for lexing, parsing, interpreting and testing single \emph{nutsh} files as described in \cref{sec:lang}. For parsing, this package uses \textsc{YACC}, a widely used $LALR(1)$ parser generator that takes a list of token types, a grammar description and an operator precedence declaration and then generates a function that receives tokens from the lexer and parses them. Go comes with its own YACC implementation.\footnote{\url{http://golang.org/cmd/yacc/}}

%Refer to \cref{sec:usage} for installation and usage instructions.

%\subsection*{Parsing}
%
%
%(ref: http://dinosaur.compilertools.net/yacc/)

\chapter{Application and Evaluation}
\label{sec:evaluation}

To find out whether the tutorials created with the Nut Shell has any advantages compared to traditional teaching methods, we created an example tutorial and conducted a two-week course with a subsequent survey.

\section{Setting}

The \textit{Institute for Programming and Reactive Systems} at the \textsc{Braunschweig University of Technology} has been organizing preparatory computer science courses for freshman students since 2003. This course teaches how to use UNIX-like operating systems and accompaning tools for program creation.

Until now, these topics were tought by handing out exercises on paper, which the students could work on in computer pools. For support, student assistants were provided, with about one assistant per 40 students.

In the fall semester 2013--2014, 150 students enrolled in the course. For this study, the students were split into two groups: Two thirds of the students were randomly selected to use the Nut Shell, the remaining one third worked with the previously used exercises on paper. The groups worked in two separate rooms. Each day, there were three time slots of 75 minutes each, to which the students were assigned in equal parts. The course spanned over eight days, not including a weekend and a day off.

The course roughly covered the following topics: The \textsc{UNIX} file system and how to manipulate it; various text editors like Vim, Emacs, and Gedit; process management; command line tools for text manupulation like \texttt{grep}, \texttt{sort}, or \texttt{patch}; various shell mechanism like output redirection and the command history; shell scripts; automatition with Makefiles; accessing remote servers with \textsc{SSH}; typesetting documents with \LaTeX; understanding and repairing programs written in \textit{Java}; and version control with \textit{Git}.

The newly created \textit{Nut Shell} tutorial kept these topics and their order. The material was divided into 30 invidiual lessons, each of which covered one specific topic. Each day, new lessons were made available. In total, the tutorial contained 2875 lines of \textit{nutsh} code. It took about 30 hours to write and test the lessons. Refer to \cref{sec:nutshexample} for an example lesson. \Cref{sec:lessons} gives a complete list of the created lessons.

\section{Style}

The basic structure in the Nut Shell tutorial when introducing new concepts is the following: First, a general problem is stated. The method or tool for solving this class of problems is presented using a simple example, in which the user is guided exactly what to do. After that follow several problems of increasing difficulty which the user has to solve on his own. Finally, some advanced concepts and ideas are mentioned, and the user is given some free room to experiment with those. A clear signal is communicated that the user can use to continue.

Often, goals are stated, but how to achieve them is up to the user. This is realized by testing against \texttt{output()} and especially \texttt{run()} statements. At several occasions, the user can choose among several paths to continue or can determine in which order to learn about several topics. These structures are supposed to give the user a feeling of autonomy and control.

For better illustration and for a more entertaining experience, the lessons introduce several real-world metaphors for abstract concepts. For example, in a lesson about the compression of files, the user is confronted with a directory named \textit{fridge} and a large file named \textit{elephant} and is asked to put the elephant in the fridge.\footnote{This is a reference to the old joke “How do you put an elephant into a fridge? -- Open the fridge, put in the elephant, and close the door.”} To complete this task, the file has to be compressed. The lessons took place in a virtual environment that consisted of several directories named \emph{kitchen} or \emph{bedroom} and often involved files named after real-life objects.

\section{Survey}

After the sixth day, an online survey was conducted whithin both groups. In the first part, the following general questions were asked (in German):

\begin{itemize}
    \item On a range from 1 (not at all) to 10 (entirely), how much do you agree to the following statements?
        \begin{enumerate}
            \item I had previous knowledge about the command line.
            \item The tutorial was fun.
            \item I learned a lot in the tutorial.
            \item The exercises were too hard.
            \item I had enough time to complete the exercises.
            \item I think the material is relevant for my further education.
            \item I would recommend the tutorial to others.
        \end{enumerate}
    \item How many times did you have to ask for help per day?
\end{itemize}

The second part of the survey was a test with 11 questions about different topics of the tutorial, in an attempt to quantify how much the participants learned. The following questions were provided by a person who was uninvolved with and unaware of the content of the Nut Shell lessons to avoid a bias which could have led to asking questions the author knew the Nut Shell explained well. For evaluation, each answer was marked with either 0 points (no or wrong answer), 0.5 points (partly correct), or 1 point (complete and correct answer).

\begin{enumerate}
    \item How do you create the directory \texttt{abc.txt}?
    \item How do you copy the file \texttt{abc.txt} to the directory \texttt{xyz}?
    \item How can you obtain more information about the command \texttt{mv}?
    \item Name at least two ways to look at the content of the file \texttt{abc.txt}.
    \item What is the command \texttt{ln} used for?
    \item Print all lines of the file \texttt{abc.txt} that contain the text “Hello”.
    \item What is the variable \texttt{PS1} used for?
    \item What do you use \texttt{>} and \texttt{>>} for and how do they differ?
    \item How do you archive and compress all files with the ending “123” in the current directory?
    \item What is the file \texttt{\textasciitilde/.bashrc} used for?
    \item You don't want to type \texttt{ls -alR} all the time, but create a short hand form. Which possibilities do you have and what are the corresponding commands?
    \item What are pipes used for and how do you use them? Write an example command.
\end{enumerate}

The third batch of questions was only given to the students who had used the Nut Shell. It was intended to assess strengths and weaknesses of the created tutorial. Again, they were asked to rank the statements on a scale from 1 to 10:

\begin{itemize}
    \item The Nut Shell did a good job explaining new material.
    \item When I encountered problems, the Nut Shell gave helpful hints.
    \item The exercises were helpful to understand the topics on hand.
    \item When attending another course, I would like to use the Nut Shell again.
\end{itemize}

\section{Results}

For the survey's first part, there were 64 answers in total. 53 of the participants specified they had used the Nut Shell, 11 of them had used the exercise sheets. \Cref{fig:general} juxtaposes the answers to the general questions in both groups in the form of a box plot: The circle marks the median of the answers to each question, the box contains 50\% of the answers, the whiskers reach from the minimum to the maximum answer. The Nut Shell users had more fun and had the impression of having learned more than the exercise users. The \emph{unpaired two-sample t-test} \cite{student08} yields $p$-values of $0.054$ respectively $0.060$, which means that there is a chance of 5--6\% that this difference is accountable to random. While there is slight evidence that the Nut Shell users found the course easier, had less time, and thought of the topics to be more relevant, these differences are not statistically significant.

\begin{figure}[p]
    \begin{tikzpicture}[trim axis left, trim axis right]
        \begin{axis}[
                boxplotcompare style,
                ytick={1,2,3,4,5,6,7},
                yticklabels={Prior knowl., Fun, Learned a lot, Too hard, Enough time, Relevant, Recommend},
                boxplot,
                y dir=reverse,
                height=\textheight,
                width=\textwidth,
                xmin=0.5,
                xmax=10.5,
                xmajorgrids,
                ymin=0,
                ymax=8,
            ]

            \addlegendimage{area legend, fill=gray, draw=black}
            \addlegendentry{Nut Shell};
            \addlegendimage{area legend, fill=white, draw=black}
            \addlegendentry{Exercise Sheets};

            \addplot[
                forget plot,
                rshift,
                boxplot prepared={
                    lower whisker =1,
                    lower quartile=1,
                    median        =2,
                    upper quartile=4.25,
                    upper whisker =10,
                },
            ] coordinates {};
            \addplot[
                lshift,
                boxplot prepared={
                    lower whisker =1,
                    lower quartile=1,
                    median        =1.5,
                    upper quartile=2.25,
                    upper whisker =3,
                },
            ] coordinates {};

            \addplot[% fun
                forget plot,
                rshift,
                boxplot prepared={
                    lower whisker =3,
                    lower quartile=7,
                    median        =9,
                    upper quartile=10,
                    upper whisker =10,
                },
            ] coordinates {};
            \addplot[
                lshift,
                boxplot prepared={
                    lower whisker =6,
                    lower quartile=7,
                    median        =8,
                    upper quartile=8,
                    upper whisker =10,
                },
            ] coordinates {};

            \addplot[% learn
                forget plot,
                rshift,
                boxplot prepared={
                    lower whisker =5,
                    lower quartile=8,
                    median        =9,
                    upper quartile=9.25,
                    upper whisker =10,
                },
            ] coordinates {};
            \addplot[
                lshift,
                boxplot prepared={
                    lower whisker =5,
                    lower quartile=7,
                    median        =7.5,
                    upper quartile=9,
                    upper whisker =10,
                },
            ] coordinates {};

            \addplot[% too hard
                forget plot,
                rshift,
                boxplot prepared={
                    lower whisker =1,
                    lower quartile=3,
                    median        =4,
                    upper quartile=5,
                    upper whisker =9,
                },
            ] coordinates {};
            \addplot[
                lshift,
                boxplot prepared={
                    lower whisker =2,
                    lower quartile=2.75,
                    median        =4.5,
                    upper quartile=5.25,
                    upper whisker =7,
                },
            ] coordinates {};

            \addplot[% enough time
                forget plot,
                rshift,
                boxplot prepared={
                    lower whisker =3,
                    lower quartile=7,
                    median        =9,
                    upper quartile=10,
                    upper whisker =10,
                },
            ] coordinates {};
            \addplot[
                lshift,
                boxplot prepared={
                    lower whisker =3,
                    lower quartile=8.75,
                    median        =10,
                    upper quartile=10,
                    upper whisker =10,
                },
            ] coordinates {};

            \addplot[% relevant
                forget plot,
                rshift,
                boxplot prepared={
                    lower whisker =5,
                    lower quartile=7,
                    median        =8,
                    upper quartile=9,
                    upper whisker =10,
                },
            ] coordinates {};
            \addplot[
                lshift,
                boxplot prepared={
                    lower whisker =5,
                    lower quartile=6.75,
                    median        =7.5,
                    upper quartile=8.25,
                    upper whisker =10,
                },
            ] coordinates {};

            \addplot[% recommend
                forget plot,
                rshift,
                boxplot prepared={
                    lower whisker =4,
                    lower quartile=8,
                    median        =9,
                    upper quartile=10,
                    upper whisker =10,
                },
            ] coordinates {};
            \addplot[
                lshift,
                boxplot prepared={
                    lower whisker =6,
                    lower quartile=7.75,
                    median        =9,
                    upper quartile=10,
                    upper whisker =10,
                },
            ] coordinates {};
        \end{axis}
    \end{tikzpicture}
    \centering
    \caption{Answers to general questions.}
    \label{fig:general}
\end{figure}

\Cref{fig:help} shows the answers to the question regarding how many times per day the participants needed support from a student assistant. Clearly, the Nut Shell users only needed half as much help compared to the exercise users.

\begin{figure}[tb]
    \begin{tikzpicture}[trim axis left, trim axis right]
        \begin{axis}[
                boxplotcompare style,
                ytick={1},
                yticklabels={Help/day},
                boxplot,
                y dir=reverse,
                height=0.32\textwidth,
                width=\textwidth,
                xmin=-0.5,
                xmax=10.5,
                xmajorgrids,
                ymin=0.2,
                ymax=1.5,
            ]

            \addlegendimage{area legend, fill=gray, draw=black}
            \addlegendentry{Nut Shell};
            \addlegendimage{area legend, fill=white, draw=black}
            \addlegendentry{Exercise Sheets};

            \addplot[
                forget plot,
                rshift,
                boxplot prepared={
                    lower whisker =0,
                    lower quartile=1,
                    median        =1.5,
                    upper quartile=3,
                    upper whisker =10,
                },
            ] coordinates {};
            \addplot[
                lshift,
                boxplot prepared={
                    lower whisker =1,
                    lower quartile=2,
                    median        =4,
                    upper quartile=5.5,
                    upper whisker =10,
                },
            ] coordinates {};
        \end{axis}
    \end{tikzpicture}
    \centering
    \caption{Times the participants had to ask for help per day.}
    \label{fig:help}
\end{figure}

\Cref{fig:test} shows the distribution of test scores. The hightest achievable score was $12$. The test was filled out by 53 people: 43 were users of the Nut Shell and 10 used the exercise sheets. On average, the exercise sheet group achieved a slightly higher score, but again, this result is not statistically relevant.

\begin{figure}[tb]
    \begin{tikzpicture}[trim axis left, trim axis right]
        \begin{axis}[
                boxplotcompare style,
                ytick={1},
                yticklabels={Score},
                boxplot,
                y dir=reverse,
                height=0.32\textwidth,
                width=\textwidth,
                xmin=-0.5,
                xmax=12.5,
                xmajorgrids,
                ymin=0.2,
                ymax=1.5,
            ]

            \addlegendimage{area legend, fill=gray, draw=black}
            \addlegendentry{Nut Shell};
            \addlegendimage{area legend, fill=white, draw=black}
            \addlegendentry{Exercise Sheets};

            \addplot[
                forget plot,
                rshift,
                boxplot prepared={
                    lower whisker =3,
                    lower quartile=5,
                    median        =6,
                    upper quartile=7.5,
                    upper whisker =12,
                },
            ] coordinates {};
            \addplot[
                lshift,
                boxplot prepared={
                    lower whisker =3,
                    lower quartile=5.75,
                    median        =7,
                    upper quartile=8.375,
                    upper whisker =9,
                },
            ] coordinates {};
        \end{axis}
    \end{tikzpicture}
    \centering
    \caption{Points that the participants got in the test.}
    \label{fig:test}
\end{figure}

\Cref{fig:meta} shows the answers to the Nut Shell related questions. The initial explanations as well as the exercises received high scores, with a median of $9$, the tips for solving the exercises received a median score of $7$. Over half of the participants would like to use the Nut Shell again for a future tutorial.

\begin{figure}[tb]
    \begin{tikzpicture}[trim axis left, trim axis right]
        \begin{axis}[
                boxplotcompare style,
                ytick={1,2,3,4},
                yticklabels={Explanations, Tips, Exercises, Use again},
                boxplot,
                y dir=reverse,
                height=0.3\textheight,
                width=\textwidth,
                xmin=0.5,
                xmax=10.5,
                xmajorgrids,
                ymin=0,
                ymax=5,
            ]

            \addplot[%explanation
                fill=gray,
                boxplot prepared={
                    lower whisker =5,
                    lower quartile=8,
                    median        =9,
                    upper quartile=10,
                    upper whisker =10,
                    box extend=0.6,
                },
            ] coordinates {};
            \addplot[%help
                fill=gray,
                boxplot prepared={
                    lower whisker =2,
                    lower quartile=5,
                    median        =7,
                    upper quartile=8,
                    upper whisker =10,
                    box extend=0.6,
                },
            ] coordinates {};
            \addplot[%exercises
                fill=gray,
                boxplot prepared={
                    lower whisker =4,
                    lower quartile=7,
                    median        =9,
                    upper quartile=10,
                    upper whisker =10,
                    box extend=0.6,
                },
            ] coordinates {};
            \addplot[%again
                fill=gray,
                boxplot prepared={
                    lower whisker =5,
                    lower quartile=8,
                    median        =10,
                    upper quartile=10,
                    upper whisker =10,
                    box extend=0.6,
                },
            ] coordinates {};
        \end{axis}
    \end{tikzpicture}
    \centering
    \caption{Answers to Nut Shell related questions.}
    \label{fig:meta}
\end{figure}

\Cref{fig:participants} shows the number of participants per day in both groups. In this case, from the initial 80 Nut Shell users, 63.8\% stayed until the last day. Of the exercise sheet users, only 24.4\% of the initial 45 stayed. On the next-to-last day, 83.8\% of the Nut Shell users and 33.3\% of the exercise sheet users attended. Of the 52 Nut Shell students who attended on the last day, 42 (80.8\%) actually completed the tutorial.

\begin{figure}[tb]
    \begin{tikzpicture}[trim axis left, trim axis right]
        \pgfplotstableread{ % Read the data into a table macro
            Label	Slot1	Slot2	Slot3	a	b	c
            1	29	26	25	15	15	15
            2	25	28	24	9	15	5
            3	30	25	16	9	10	15
            4	24	22	16	9	12	5
            5	25	19	11	6	10	1
            6	0	0	0 	0	0	0
            7	0	0	0 	0	0	0
            8	23	28	12	9	11	2
            9	25	23	19	9	6	0
            10	0	0	0 	0	0	0
            11	25	20	6 	10	1	0
        }\datatable

        \begin{axis}[
                width=\textwidth,
                height=0.6\textheight,
                ybar stacked,
                ymin=0,
                xmin=-1,
                xmax=11,
                xtick=data,
                xticklabels from table={\datatable}{Label},
                xlabel=Day,
                ylabel=Participants,
                ymajorgrids,
            ]

            \addlegendimage{area legend, fill=gray, draw=black}
            \addlegendentry{Nut Shell};
            \addlegendimage{area legend, fill=white, draw=black}
            \addlegendentry{Exercise Sheets};

            \addplot [fill=gray, bar shift=-.2cm] table [y=Slot1, x expr=\coordindex] {\datatable};    % Plot the "First" column against the data index
            \addplot [fill=gray, bar shift=-.2cm] table [y=Slot2, x expr=\coordindex] {\datatable};
            \addplot [fill=gray, bar shift=-.2cm] table [y=Slot3, x expr=\coordindex] {\datatable};

            \resetstackedplots

            \addplot [fill=white, bar shift=.2cm] table [y=a, x expr=\coordindex] {\datatable};
            \addplot [fill=white, bar shift=.2cm] table [y=b, x expr=\coordindex] {\datatable};
            \addplot [fill=white, bar shift=.2cm] table [y=c, x expr=\coordindex] {\datatable};
        \end{axis}
    \end{tikzpicture}
    \centering
    \caption{Number of participants per day. Days 6 and 7 were a weekend, there was no course on day 10. From bottom to top, the bar's segments represent first, second and third time slot.}
    \label{fig:participants}
\end{figure}

\section{Discussion}

The small number of participants in the exercise sheet group who participated in the survey is a problem for proper evaluation: The results are likely to be warped, as just those participants who had fun and learned something stayed, while the students that were bored or learned nothing stopped attending the course.

That is why the evaluation approach shifted toward looking at the number of participants over time. According to the course's organizers and former assistants, the high participant loss that occurred in the exercise sheet group is indeed typical and representative. This could mean that the Nut Shell lesson motivated the students more to attend to the course. From a lecturer's perspective, this result of having 63.8\% of the students attending over the whole timespan, is highly gratifying.

Another positive result is the lowered demand for external help the Nut Shell users had. On the one hand, this is pleasing for the students themselves, as they can learn more independently---for example, from home, where no external help is available. On the other hand, the number of required student assistants can be lowered, leading to reduced costs for the university while apparently maintaining about the same quality of education.

\chapter{Conclusions and Future Work}
\label{sec:conclusions}

Because of the evaluation's positive outcome, the Nut Shell will be used for the upcoming preparatory courses exclusively. Another institute has already shown interest to use the Nut Shell for a more in-depth course on the version control software \emph{Git}. During the preparatory course, a participating student told us he would like to use the Nut Shell to teach command line concepts to pupils at his old school.

The student's general feedback during the evaluation was very positive. Some were eager to install Linux on their own computers so they could continue to use the tutorial. Some requested that the Nut Shell should be made available in all the university's Linux computer rooms. Another path was chosen: Because the program is a terminal application, it can be used remotely via an SSH connection. It is now possible to use the Nut Shell on the university's shell server from virtually everywhere.

Development of the Nut Shell will continue. The software and the tutorial will be released under a free, open source license to allow everyone to use them and to create new tutorials using the \emph{nutsh} language.

\subsection*{Future work}

There is a lot of potential for further development. Right now, typing errors can only be catched by defining appropriate \texttt{command} checks by hand. The \texttt{expect}-statements could be used to automate the detection of these errors by measuring the \emph{edit distance}\footnote{For example, the Levenshtein distance, that detects insertions, deletions and substitutions \cite{levenshtein66}.} between the entered and the expected commands. When the distance falls below a certain threshold, the correct command could be suggested to the user.

Although the syntax of the \texttt{prompt} statement clearly communicates its semantic structure, in practical use it seems cumbersome, as it is repeated so often. The syntax could be simplified here, so that blocks of \texttt{if} clauses imply a \texttt{prompt} statement around them. Another language element for preventing this automation would have to be added as well.

Right now, the lessons of a tutorial follow a linear order. It would make sense to structure them as a dependency graph, in which the tutorial's author can specify for each lesson, which other lessons have to be finished before. This would give the user more freedom to navigate through the tutorial autonomously.

The users' feedback while using the tutorial can be very valuable to improve it. This feedback collection could be automated by recording the user's interaction and tracking their progress over time. For example, when users do not reach new \texttt{prompt} statements for a longer time period, or enter disproportionately many commands in one \texttt{prompt} loop, this could indicate that this section is too hard and should contain more hints. Misspelled or unhelpful commands could also be automatically collected, analyzed, and be presented to the author so that he can add appropriate hints to the lesson.

\appendix

\chapter{Example \emph{nutsh} Lesson}
\label{sec:nutshexample}

This chapter contains an actual lesson from the preparatory course, translated into English. The lesson explains how to compress files and directories using UNIX command line tools---the students already learned how to move and display files.

The first listing demonstrates how the lesson looks like during execution. Text set in a bold typeface is entered by the user, the italic tutorial text would be displayed in a different color. The second half of the chapter, starting on page \cpageref{lst:compress}, displays the lesson's \emph{nutsh} source code.

\lstinputlisting[language=commandline,frame=tbrl,basicstyle=\ttfamily\footnotesize]{compress.output}
%
And here is the lesson's \emph{nutsh} source code. The first file contains some reusable functions shared by all lessons, the second one is the actual lesson. The source code demonstrates all of \emph{nutsh}'s syntactic structures and is commented as needed.

\label{lst:compress}
\lstinputlisting[title=common.nutsh,language=nutsh,frame=tbrl,basicstyle=\ttfamily\footnotesize]{common.nutsh}

\lstinputlisting[title=compress.nutsh,language=nutsh,frame=tbrl,basicstyle=\ttfamily\footnotesize]{compress.nutsh}

\chapter{List of Lessons Used in the Evaluation}
\label{sec:lessons}

The following lessons were part of the preparatory course:

\begin{multicols}{2}
    \footnotesize
    \begin{enumerate}
        \item Introduction - first examples with \texttt{cal}
        \item Looking and moving around - \texttt{ls} and \texttt{cd}
        \item Helping users to help themselves \texttt{-} man
        \item File system and paths
        \item Creating and editing files - \texttt{mkdir} and editors
        \item History and tab completion
        \item Java
        \item Deleting files and directories - \texttt{rmdir\texttt{},} rm
        \item Copying, moving and linking files - \texttt{cp}, \texttt{mv}, \texttt{ln}
        \item Process management - \texttt{ps}
        \item Aliases
        \item Variables
        \item Commandline editing
        \item Wildcards
        \item Quoting
        \item Compressing files - \texttt{tar}, \texttt{gzip}, \texttt{bzip2}
        \item Redirection and pipes
        \item Looking for patterns - \texttt{grep}
        \item Small useful commands
        \item \texttt{wget} and \texttt{curl}
        \item Typesetting with \LaTeX
        \item Java, part 2
        \item Comparing files - \texttt{cmp}, \texttt{diff}, \texttt{patch}
        \item Searching - \texttt{find}, \texttt{locate}
        \item Sorting
        \item Shell scripts
        \item Version control with Git
        \item Working remotely with SSH
        \item Automation with makefiles
    \end{enumerate}
\end{multicols}

%\chapter{Installation and Usage}
%\label{sec:usage}
%
%The Nut Shell's source code can be obtained fuu TODO.
%
%The \texttt{nutsh} program takes two parameters: The second one specifies the directory that contains the tutorial. For the first parameter, there are two options: \texttt{run} will start the Nut Shell normally and present a list of lessons to the user to choose from. \texttt{test} will run all lessons in the specified tutorial in \emph{testing mode} as described in \cref{sec:testing}.
%
%To run the tutorial created for the preparatory course, a Linux distribution is required. Furthermore, the tools used in the tutorial need to be installed: Java, \texttt{pdflatex}, Git, \texttt{make}, an SSH client, a \texttt{locate} implementation, and the GNU coreutils. In case a program is missing, it can be installed at any later time.

\listoffigures

\nocite{why05}
\nocite{fowler10}
\nocite{upt02}
\nocite{dragonbook06}
\nocite{louden03}

%\bibliographystyle{plain}
\printbibliography

\end{document}
