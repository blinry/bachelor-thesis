\documentclass[twoside]{scrreprt}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

%\usepackage{microtype}
%\usepackage{graphicx}

%\titlehead{%
%\hfill
%{\sffamily\bfseries%
%\makebox[\textwidth]{TECHNISCHE UNIVERSIT\"AT CAROLO-WILHELMINA ZU BRAUNSCHWEIG}}
%}

\subject{Bachelor Thesis}
\title{The Nut Shell \\ A Framework for Creating Interactive Command Line Tutorials}
\author{Sebastian Morr}
\date{\today}
\publishers{Betreuer: Dr. Werner Struckmann}

\begin{document}

\maketitle

\tableofcontents

\begin{abstract}
(Purpose)

(Design + evaluation methods)

(Major results)

(Summary of conclusions)
\end{abstract}

\chapter{Introduction}

Command line interfaces are a powerful way to interact with computers, but they have a steep learning curve. An effective way to learn how to use them is by using a tutorial - (definition).

The common way of teaching command line interfaces is a static text. This representation has several disadvantages: The users have to shift their attention forth and back between the tutorial text and the system they are learning, which could make the learning process ineffective. The text might set goals, but those aren't affirmed when they are reached. Last, when the user makes a syntactical or semantical mistake, the text does not respond to help the user fix it.

This thesis describes a system that strives to fix those problems. The core idea is to interlace the tutorial text and the command line output so that the text can respond to the state of the command line system. This approach is inspired by text adventures.

The main research question of this thesis is whether this approach is in some way "better" than the traditional text tutorials.

In the technical community, there have been several approaches in creating interactive tutorials for command line interfaces, most notably (Try Ruby/Git/Haskell).

(What's missing in them)

\chapter{Overview}

The \emph{Nut Shell} is designed to be a wrapper around a common command line process. There are several, but at the core their output can be split into three phases: Output of a prompt, composing the command, and execution/output of the command.

(Diagram of loop?)

(Goals and principles)

(Adaptability to arbitrary "targets")

(Annotation + environment changing, otherwise raw CLI interaction)

This thesis covers design, implementation, application and evaluation of the \emph{Nut Shell}.

Design-wise, (Diagram: Layers)

(impl)

(app, eval)

\chapter{Command Line Parser}

\section{Purpose}

In this thesis, the target command line process is treated as a black box - we only capture its output and input.

To recognize which commands the user entered and what the corresponding output is, we need to parse the output accordingly.

\section{Background}

        (How a terminal works)

        (Escape characters)

        (Readline key combinations)

\section{Architecture}

        (Component diagram)

        (Parser EBNF)

\section{Problems and Workarounds}

        (Command line editing)

        (...)

\chapter{Internal DSL}

    (Purpose: High-level layer around CLI parser)

    (Description of necessary DSL calls)

\chapter{The nutsh Language}

\section{Purpose}

        (Describes a self-contained teaching unit, a "lesson")

\section{Design Goals}

        (Easy to read and write)

            (Use syntax the user already knows: Regex + Go syntax)

            (Introduce new syntax for often-used semantics)

        (Minimize redundance)

            (DRY, allow reuse of code snippets)

\section{Properties}

        (String-based)

        (Functional)

\section{Lexical Elements}

        (Token types)

        (Diagram: State machine)

\section{Syntax}

        (EBNF of language constructs)

\section{Parsing}

        (How YACC works)

\section{Semantics}

        (Specification of language constructs)

\section{Interpreter}

        (State)

        (Function stack)

\section{Automated Testing}

        (Motivation)

        (Testing algorithm)

\section{Examples}

\chapter{Implementation}

\section{Used Technologies}

    (Go)

    (kr/pty for terminal emulation)

\section{High-level Design}

    (Diagram: Package diagram)

\section{Command Line Tool}

\subsection{Usage}

\subsection{Builtin Functions}

\chapter{Application and Evaluation}

\section{Setting}

        (Description of setting: Preparatory course for CS students)

        (Previous teaching method)

        (Groups)

\section{Tutorial}

        (Content, examples)

        (Best practises in lesson writing)

\section{Survey}

        (Questions)

\section{Results}

    (Pretty graphs)

    (Statistical evaluation)

\chapter{Conclusions}

(Discussion of survey results)

\chapter{Limitations and Future Directions}

Right now, typing errors can be catched by defining some command-rules by hand. The expect-Statements could be used to automate this detection of typing errors by applying (algorithm).

    (Simplified prompt syntax)

    (Lesson dependency tree)

I plan to extend the Nut Shell further and release it under an Open Source license to allow others to benefit from it.

\chapter{Acknowledgements}

I thank the following people for support and valuable discussions:

Heike Laschin
Markus Reschke
Werner Struckmann
Hauke Baller
Hendrik Freytag

\chapter{References}

(...)

\appendix

\chapter{Example Lesson}

(nutsh source code)

(Execution output)

\chapter{Table of Terminal Escape Codes}

(...)

\chapter*{Affidavit}

("Erkl√§rung an Eides statt")

\end{document}
